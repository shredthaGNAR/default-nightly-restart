{
    "sourceFile": "boot.jsm",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 0,
            "patches": [
                {
                    "date": 1633421805191,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                }
            ],
            "date": 1633421805191,
            "name": "Commit-0",
            "content": "let EXPORTED_SYMBOLS = [];\n\nconsole.warn( \"Browser is executing custom scripts via autoconfig\" );\nconst {Services} = ChromeUtils.import('resource://gre/modules/Services.jsm');\n\nconst yPref = {\n  get: function (prefPath) {\n    const sPrefs = Services.prefs;\n    try {\n      switch (sPrefs.getPrefType(prefPath)) {\n        case 0:\n          return undefined;\n        case 32:\n          return sPrefs.getStringPref(prefPath);\n        case 64:\n          return sPrefs.getIntPref(prefPath);\n        case 128:\n          return sPrefs.getBoolPref(prefPath);\n      }\n    } catch (ex) {\n      return undefined;\n    }\n    return;\n  },\n  set: function (prefPath, value) {\n    const sPrefs = Services.prefs;\n    switch (typeof value) {\n      case 'string':\n        return sPrefs.setCharPref(prefPath, value) || value;\n      case 'number':\n        return sPrefs.setIntPref(prefPath, value) || value;\n      case 'boolean':\n        return sPrefs.setBoolPref(prefPath, value) || value;\n    }\n    return;\n  },\n  addListener:(a,b)=>{ let o = (q,w,e)=>(b(yPref.get(e),e)); Services.prefs.addObserver(a,o);return{pref:a,observer:o}},\n  removeListener:(a)=>( Services.prefs.removeObserver(a.pref,a.observer) )\n};\n\nconst SHARED_GLOBAL = {};\nObject.defineProperty(SHARED_GLOBAL,\"widgetCallbacks\",{value:new Map()});\n\nfunction resolveChromeURL(str){\n  const registry = Cc[\"@mozilla.org/chrome/chrome-registry;1\"].getService(Ci.nsIChromeRegistry);\n  try{\n    return registry.convertChromeURL(Services.io.newURI(str.replace(/\\\\/g,\"/\"))).spec\n  }catch(e){\n    console.error(e);\n    return \"\"\n  }\n}\n// relative to \"chrome\" folder\nfunction resolveChromePath(str){\n  let parts = resolveChromeURL(str).split(\"/\");\n  return parts.slice(parts.indexOf(\"chrome\") + 1,parts.length - 1).join(\"/\");\n}\n\nfunction traverseToMainProfile(str){\n  let dir = Services.dirsvc.get(str,Ci.nsIFile);\n  if (!dir.exists()) {\n    let toAddChrome = false;\n    while (dir.target.includes('chrome_debugger_profile')) {\n      dir = dir.parent;\n      toAddChrome = true;\n    }\n    if (toAddChrome) dir.append('chrome');\n  }\n  return dir;\n}\n\nlet _uc = {\n  BROWSERCHROME: 'chrome://browser/content/browser.xhtml',\n  PREF_ENABLED: 'userChromeJS.enabled',\n  PREF_SCRIPTSDISABLED: 'userChromeJS.scriptsDisabled',\n\n  SCRIPT_DIR: resolveChromePath('chrome://userscripts/content/'),\n  RESOURCE_DIR: resolveChromePath('chrome://userchrome/content/'),\n  BASE_FILEURI: Services.io.getProtocolHandler('file').QueryInterface(Ci.nsIFileProtocolHandler).getURLSpecFromDir(traverseToMainProfile('UChrm')),\n  \n  SESSION_RESTORED: false,\n  \nget chromeDir() {return traverseToMainProfile('UChrm')},\n\n  getDirEntry: function(filename,isLoader = false){\n    filename = filename.replace(\"\\\\\",\"/\");\n    let pathParts = ((filename.startsWith(\"..\") ? \"\" : (isLoader ? _uc.SCRIPT_DIR : _uc.RESOURCE_DIR)) + \"/\" + filename)\n                    .split(\"/\").filter( (a) => (!!a && a != \"..\") );\n    let entry = _uc.chromeDir;\n    \n    for(let part of pathParts){\n      entry.append(part)\n    }\n    if(!entry.exists()){\n      return null\n    }\n    if(entry.isDirectory()){\n      return entry.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n    }else if(entry.isFile()){\n      return entry\n    }else{\n      return null\n    }\n  },\n  \n  updateStyleSheet: function(name,type) {\n    if(type){\n      let sss = Cc['@mozilla.org/content/style-sheet-service;1'].getService(Ci.nsIStyleSheetService);\n      try{\n        let uri = Services.io.newURI(`chrome://userchrome/content/${name}`);\n        switch(type){\n          case \"agent\":\n            sss.unregisterSheet(uri,sss.AGENT_SHEET);\n            sss.loadAndRegisterSheet(uri,sss.AGENT_SHEET);\n            return true\n          case \"author\":\n            sss.unregisterSheet(uri,sss.AUTHOR_SHEET);\n            sss.loadAndRegisterSheet(uri,sss.AUTHOR_SHEET);\n            return true\n          default:\n            return false\n        }\n      }catch(e){\n        console.error(e);\n        return false\n      }\n    }\n    let entry = _uc.utils.getFSEntry(name);\n    if(!(entry && entry.isFile())){\n      return false\n    }\n    let recentWindow = Services.wm.getMostRecentBrowserWindow();\n    if(!recentWindow){\n      return false\n    }\n    function recurseImports(sheet,all){\n      let z = 0;\n      let rule = sheet.cssRules[0];\n      // loop through import rules and check that the \"all\"\n      // doesn't already contain the same object\n      while(rule instanceof CSSImportRule && !all.includes(rule.styleSheet) ){\n        all.push(rule.styleSheet);\n        recurseImports(rule.styleSheet,all);\n        rule = sheet.cssRules[++z];\n      }\n      return all\n    }\n    \n    let sheets = recentWindow.InspectorUtils.getAllStyleSheets(recentWindow.document,false);\n    \n    sheets = sheets.flatMap( x => recurseImports(x,[x]) );\n    \n    // If a sheet is imported multiple times, then there will be\n    // duplicates, because style system does create an object for\n    // each instace but that's OK since sheets.find below will\n    // only find the first instance and reload that which is\n    // \"probably\" fine.\n    let entryFilePath = `file:///${entry.path.replaceAll(\"\\\\\",\"/\")}`;\n    \n    let target = sheets.find(sheet => sheet.href === entryFilePath);\n    if(target){\n      recentWindow.InspectorUtils.parseStyleSheet(target,_uc.utils.readFile(entry));\n      return true\n    }\n    return false\n  },\n\n  getScripts: function () {\n    this.scripts = {};\n    if(!yPref.get(_uc.PREF_ENABLED) || !(/^[\\w_]*$/.test(_uc.SCRIPT_DIR))){\n      console.log(\"Scripts are disabled or the given script directory name is invalid\");\n      return\n    }\n    let files = _uc.getDirEntry('',true);\n    while(files.hasMoreElements()){\n      let file = files.getNext().QueryInterface(Ci.nsIFile);\n      if (/\\.uc\\.js$/i.test(file.leafName)) {\n        let script = _uc.getScriptData(file);\n        if(script.inbackground && script.isEnabled){\n          try{\n            Cu.import(`chrome://userscripts/content/${script.filename}`)\n          }catch(e){\n            console.error(e);\n        }\n      }\n      }\n    }\n  },\n\n  getScriptData: function (aFile) {\n    let header = (_uc.utils.readFile(aFile,true).match(/^\\/\\/ ==UserScript==\\s*\\n(?:.*\\n)*?\\/\\/ ==\\/UserScript==\\s*\\n/m) || [''])[0];\n    let match, rex = {\n      include: [],\n      exclude: []\n    };\n    let findNextRe = /^\\/\\/ @(include|exclude)\\s+(.+)\\s*$/gm;\n    while ((match = findNextRe.exec(header))) {\n      rex[match[1]].push(match[2].replace(/^main$/i, _uc.BROWSERCHROME).replace(/\\*/g, '.*?'));\n    }\n    if (!rex.include.length) {\n      rex.include.push(_uc.BROWSERCHROME);\n    }\n    let exclude = rex.exclude.length ? `(?!${rex.exclude.join('$|')}$)` : '';\n    let def = ['', ''];\n    let author = (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1];\n    let filename = aFile.leafName || '';\n\n    return this.scripts[filename] = {\n      filename: filename,\n      name: (header.match(/\\/\\/ @name\\s+(.+)\\s*$/im) || def)[1],\n      charset: (header.match(/\\/\\/ @charset\\s+(.+)\\s*$/im) || def)[1],\n      description: (header.match(/\\/\\/ @description\\s+(.+)\\s*$/im) || def)[1],\n      version: (header.match(/\\/\\/ @version\\s+(.+)\\s*$/im) || def)[1],\n      author: (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1],\n      regex: new RegExp(`^${exclude}(${rex.include.join('|') || '.*'})$`,'i'),\n      id: (header.match(/\\/\\/ @id\\s+(.+)\\s*$/im) || ['', filename.split('.uc.js')[0] + '@' + (author || 'userChromeJS')])[1],\n      homepageURL: (header.match(/\\/\\/ @homepageURL\\s+(.+)\\s*$/im) || def)[1],\n      downloadURL: (header.match(/\\/\\/ @downloadURL\\s+(.+)\\s*$/im) || def)[1],\n      updateURL: (header.match(/\\/\\/ @updateURL\\s+(.+)\\s*$/im) || def)[1],\n      optionsURL: (header.match(/\\/\\/ @optionsURL\\s+(.+)\\s*$/im) || def)[1],\n      startup: (header.match(/\\/\\/ @startup\\s+(.+)\\s*$/im) || def)[1],\n      //shutdown: (header.match(/\\/\\/ @shutdown\\s+(.+)\\s*$/im) || def)[1],\n      onlyonce: /\\/\\/ @onlyonce\\b/.test(header),\n      inbackground: /\\/\\/ @backgroundmodule\\b/.test(header),\n      isRunning: false,\n      get isEnabled() {\n        return (yPref.get(_uc.PREF_SCRIPTSDISABLED) || '').split(',').indexOf(this.filename) === -1;\n      }\n    }\n  },\n\n  //everLoaded: [],\n  \n  maybeRunStartUp: (script,win) => {\n    if( script.startup\n        && (/^\\w*$/).test(script.startup)\n        && SHARED_GLOBAL[script.startup]\n        && typeof SHARED_GLOBAL[script.startup]._startup === \"function\")\n      {\n          SHARED_GLOBAL[script.startup]._startup(win)\n      }\n  },\n  \n  loadScript: function (script, win) {\n    if (script.inbackground || !script.regex.test(win.location.href) || !script.isEnabled) {\n      return\n    }\n    try {\n      if (script.onlyonce && script.isRunning) {\n        _uc.maybeRunStartUp(script,win)\n        return\n      }\n\n      Services.scriptloader.loadSubScript(`chrome://userscripts/content/${script.filename}`, win);\n      \n      script.isRunning = true;\n      _uc.maybeRunStartUp(script,win);\n      \n      /*if (!script.shutdown) {\n        this.everLoaded.push(script.id);\n      }*/\n    } catch (ex) {\n      console.error(ex);\n    }\n    return\n  },\n\n  // things to be exported for use by userscripts\n  utils:{\n    \n    get sharedGlobal(){ return SHARED_GLOBAL },\n    \n    createElement: function(doc,tag,props,isHTML = false){\n      let el = isHTML ? doc.createElement(tag) : doc.createXULElement(tag);\n      for(let prop in props){\n        el.setAttribute(prop,props[prop])\n      }\n      return el\n    },\n    \n    createWidget(desc){\n      if(!desc || !desc.id ){\n        console.error(\"custom widget description is missing 'id' property\");\n        return null\n      }\n      if(!(['toolbaritem','toolbarbutton']).includes(desc.type)){\n        console.error(\"custom widget has unsupported type: \"+desc.type);\n        return null\n      }\n      const CUI = Services.wm.getMostRecentBrowserWindow().CustomizableUI;\n      let newWidget = CUI.getWidget(desc.id);\n\n      if(newWidget && newWidget.hasOwnProperty(\"source\")){\n        // very likely means that the widget with this id already exists\n        // There isn't a very reliable way to 'really' check if it exists or not\n        return newWidget\n      }\n      // This is pretty ugly but makes onBuild much cleaner.\n      let itemStyle = \"\";\n      if(desc.image){\n        if(desc.type===\"toolbarbutton\"){\n          itemStyle += \"list-style-image:\";\n        }else{\n          itemStyle += \"background: transparent center no-repeat \";\n        }\n        itemStyle += `url(chrome://userChrome/content/${desc.image});`;\n        itemStyle += desc.style || \"\";\n      }\n      SHARED_GLOBAL.widgetCallbacks.set(desc.id,desc.callback);\n\n      return CUI.createWidget({\n        id: desc.id,\n        type: 'custom',\n        onBuild: function(aDocument) {\n          let toolbaritem = aDocument.createXULElement(desc.type);\n          let props = {\n            id: desc.id,\n            class: `toolbarbutton-1 chromeclass-toolbar-additional ${desc.class?desc.class:\"\"}`,\n            overflows: !!desc.overflows,\n            label: desc.label || desc.id,\n            tooltiptext: desc.tooltip || desc.id,\n            style: itemStyle,\n            onclick: `${desc.allEvents?\"\":\"event.button===0 && \"}_ucUtils.sharedGlobal.widgetCallbacks.get(this.id)(event,window)`\n          };\n          for (let p in props){\n            toolbaritem.setAttribute(p, props[p]);\n          }\n          return toolbaritem;\n        }\n      });\n    },\n    \n    readFile: function (aFile, metaOnly = false) {\n      let stream = Cc['@mozilla.org/network/file-input-stream;1'].createInstance(Ci.nsIFileInputStream);\n      let cvstream = Cc['@mozilla.org/intl/converter-input-stream;1'].createInstance(Ci.nsIConverterInputStream);\n      try{\n        stream.init(aFile, 0x01, 0, 0);\n        cvstream.init(stream, 'UTF-8', 1024, Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER);\n      }catch(e){\n        console.error(e);\n        return null\n      }\n      let content = '',\n      data = {};\n      while (cvstream.readString(4096, data)) {\n        content += data.value;\n        if (metaOnly && content.indexOf('// ==/UserScript==') > 0) {\n          break;\n        }\n      }\n      cvstream.close();\n      stream.close();\n      return content.replace(/\\r\\n?/g, '\\n');\n    },\n    \n    createFileURI: (fileName = \"\") => {\n      fileName = String(fileName);\n      let u = resolveChromeURL(`chrome://userchrome/content/${fileName}`);\n      return fileName ? u : u.substr(0,u.lastIndexOf(\"/\") + 1); \n    },\n    \n    get chromeDir(){ return {get files(){return _uc.chromeDir.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator)},uri:_uc.BASE_FILEURI} },\n    \n    getFSEntry: (fileName) => ( _uc.getDirEntry(fileName) ),\n    \n    getScriptData: () => {\n      let scripts = [];\n      for(let script in _uc.scripts){\n        let data = {};\n        let o = _uc.scripts[script];\n        for(let p in o){\n          if(p != \"isEnabled\"){\n            data[p] = o[p];\n          }\n        }\n        scripts.push(data)\n      }\n      return scripts\n    },\n    \n    get windows(){\n      return {\n        get: function (onlyBrowsers = true) {\n          let windows = Services.wm.getEnumerator(onlyBrowsers ? 'navigator:browser' : null);\n          let wins = [];\n          while (windows.hasMoreElements()) {\n            wins.push(windows.getNext());\n          }\n          return wins\n        },\n        forEach: function(fun,onlyBrowsers = true){\n          let wins = this.get(onlyBrowsers);\n          wins.forEach((w)=>(fun(w.document,w)))\n        }\n      }\n    },\n    \n    toggleScript: function(el){\n      let isElement = !!el.tagName;\n      if(!isElement && typeof el != \"string\"){\n        return\n      }\n      let script = _uc.scripts[isElement ? el.getAttribute(\"filename\") : el];\n      if(!script){\n        console.log(\"no script to toggle\");\n        return\n      }\n      if (script.isEnabled) {\n        yPref.set(_uc.PREF_SCRIPTSDISABLED, `${script.filename},${yPref.get(_uc.PREF_SCRIPTSDISABLED)}`);\n      } else {\n        yPref.set(_uc.PREF_SCRIPTSDISABLED, yPref.get(_uc.PREF_SCRIPTSDISABLED).replace(new RegExp(`^${script.filename},?|,${script.filename}`), ''));\n      }\n      Services.appinfo.invalidateCachesOnRestart();\n    },\n    \n    updateStyleSheet: function(name = \"../userChrome.css\",type){\n      return _uc.updateStyleSheet(name,type)\n    },\n    \n    updateMenuStatus: function(menu){\n      if(!menu){\n        return\n      }\n      let disabledScripts = yPref.get(_uc.PREF_SCRIPTSDISABLED).split(\",\");\n      for(let item of menu.children){\n        if (disabledScripts.includes(item.getAttribute(\"filename\"))){\n          item.removeAttribute(\"checked\");\n        }else{\n          item.setAttribute(\"checked\",\"true\");\n        }\n      }\n    },\n    \n    startupFinished: function(){\n      return new Promise(resolve => {\n        if(_uc.SESSION_RESTORED){\n          resolve();\n        }\n        let observer = (subject, topic, data) => {\n          Services.obs.removeObserver(observer, \"sessionstore-windows-restored\");\n          resolve();\n        };\n        Services.obs.addObserver(observer, \"sessionstore-windows-restored\");\n      });\n    },\n    \n    windowIsReady: function(win){\n      if(win && win.isChromeWindow){\n        return new Promise(resolve => {\n          if(win.gBrowserInit.delayedStartupFinished){\n            resolve()\n          }\n          let observer = (subject, topic, data) => {\n            if(subject === win){\n              Services.obs.removeObserver(observer, \"browser-delayed-startup-finished\");\n              resolve();\n            }\n          };\n          Services.obs.addObserver(observer, \"browser-delayed-startup-finished\");\n        });\n      }else{\n        return Promise.reject(new Error(\"reference is not a window\"))\n      }\n    },\n    \n    registerHotkey: function(desc,func){\n      const validMods = [\"accel\",\"alt\",\"ctrl\",\"meta\",\"shift\"];\n      const validKey = (k)=>((/^[\\w-]$/).test(k) ? 1 : (/^F(?:1[0,2]|[1-9])$/).test(k) ? 2 : 0);\n      const NOK = (a) => (typeof a != \"string\");\n      const eToO = (e) => ({\"metaKey\":e.metaKey,\"ctrlKey\":e.ctrlKey,\"altKey\":e.altKey,\"shiftKey\":e.shiftKey,\"key\":e.srcElement.getAttribute(\"key\"),\"id\":e.srcElement.getAttribute(\"id\")});\n      \n      if(NOK(desc.id) || NOK(desc.key) || NOK(desc.modifiers)){\n        return false\n      }\n      \n      try{\n        let mods = desc.modifiers.toLowerCase().split(\" \").filter((a)=>(validMods.includes(a)));\n        let key = validKey(desc.key);\n        if(!key || (mods.length === 0 && key === 1)){\n          return false\n        }\n        \n        _uc.utils.windows.forEach((doc,win) => {\n          if(doc.getElementById(desc.id)){\n            return\n          }\n          let details = { \"id\": desc.id, \"modifiers\": mods.join(\",\").replace(\"ctrl\",\"accel\"), \"oncommand\": \"//\" };\n          if(key === 1){\n            details.key = desc.key.toUpperCase();\n          }else{\n            details.keycode = `VK_${desc.key}`;\n          }\n\n          let el = _uc.utils.createElement(doc,\"key\",details);\n          \n          el.addEventListener(\"command\",(ev) => {func(ev.target.ownerGlobal,eToO(ev))});\n          let keyset = doc.getElementById(\"mainKeyset\") || doc.body.appendChild(_uc.utils.createElement(doc,\"keyset\",{id:\"ucKeys\"}));\n          keyset.insertBefore(el,keyset.firstChild);\n        });\n      }catch(e){\n        console.error(e);\n        return false\n      }\n      return true\n    },\n    loadURI: function(win,desc){\n      if(    !win\n          || !desc \n          || !desc.url \n          || typeof desc.url !== \"string\"\n          || !([\"tab\",\"tabshifted\",\"window\",\"current\"]).includes(desc.where)\n        ){\n        return false\n      }\n      const isJsURI = desc.url.slice(0,11) === \"javascript:\";\n      try{\n        win.openTrustedLinkIn(\n          desc.url,\n          desc.where,\n          { \"allowPopups\":isJsURI,\n            \"inBackground\":desc.where===\"tabshifted\", // This doesn't work for some reason\n            \"allowInheritPrincipal\":false,\n            \"private\":!!desc.private,\n            \"userContextId\":desc.url.startsWith(\"http\")?desc.userContextId:null});\n      }catch(e){\n        console.error(e);\n        return false\n      }\n      return true\n    },\n    get prefs(){ return yPref },\n\n    restart: function (clearCache){\n      clearCache && Services.appinfo.invalidateCachesOnRestart();\n      let cancelQuit = Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(Ci.nsISupportsPRBool);\n      Services.obs.notifyObservers(\n        cancelQuit,\n        \"quit-application-requested\",\n        \"restart\"\n      );\n      Services.startup.quit( Services.startup.eAttemptQuit | Services.startup.eRestart )\n    }\n  }\n};\n\nObject.freeze(_uc.utils);\n_uc.utils.startupFinished()\n.then(()=>{_uc.SESSION_RESTORED = true});\n\nif (yPref.get(_uc.PREF_ENABLED) === undefined) {\n  yPref.set(_uc.PREF_ENABLED, true);\n}\n\nif (yPref.get(_uc.PREF_SCRIPTSDISABLED) === undefined) {\n  yPref.set(_uc.PREF_SCRIPTSDISABLED, '');\n}\n\nfunction UserChrome_js() {\n  _uc.getScripts();\n  Services.obs.addObserver(this, 'domwindowopened', false);\n}\n\nUserChrome_js.prototype = {\n  observe: function (aSubject, aTopic, aData) {\n      aSubject.addEventListener('DOMContentLoaded', this, true);\n  },\n\n  handleEvent: function (aEvent) {\n    let document = aEvent.originalTarget;\n    let window = document.defaultView;\n    let regex = /^chrome:(?!\\/\\/global\\/content\\/(commonDialog|alerts\\/alert)\\.xhtml)|about:(?!blank)/i;\n    // Don't inject scripts to modal prompt windows or notifications\n    if(regex.test(window.location.href)) {\n      window._ucUtils = _uc.utils;\n      document.allowUnsafeHTML = false; // https://bugzilla.mozilla.org/show_bug.cgi?id=1432966\n      if(window._gBrowser){ // bug 1443849\n        window.gBrowser = window._gBrowser;\n      }\n      let isWindow = window.isChromeWindow;\n\n        /* Add a way to toggle scripts in tools menu */\n      let menu, popup, item;\n      let ce = _uc.utils.createElement;\n      if(isWindow){\n        menu = document.querySelector(\"#menu_openDownloads\");\n        if(menu){\n          try{\n            popup = ce(document,\"menupopup\",{id:\"menuUserScriptsPopup\",onpopupshown:`_ucUtils.updateMenuStatus(this)`});\n            item = ce(document,\"menu\",{id:\"userScriptsMenu\",label:\"userScripts\"});\n          }catch(e){\n            isWindow = false;\n          }\n        }else{\n          isWindow = false;\n        }\n      }\n      if(yPref.get(_uc.PREF_ENABLED)){\n        Object.values(_uc.scripts).forEach(script => {\n          _uc.loadScript(script, window);\n          if(isWindow){\n            popup.appendChild(ce(document,\"menuitem\",{type:\"checkbox\",label:script.name||script.filename,filename:script.filename,checked:\"true\",oncommand:`_ucUtils.toggleScript(this)`}))\n          }\n        });\n      }\n      if(isWindow){\n        popup.appendChild(ce(document,\"menuseparator\",{}));\n        popup.appendChild(ce(document,\"menuitem\",{label:\"Restart now!\",oncommand:\"_ucUtils.restart(true)\",tooltiptext:\"Toggling scripts requires a restart\"}));\n        item.appendChild(popup);\n        menu.parentNode.insertBefore(item,menu);\n      }\n    }\n  }\n};\n\n!Services.appinfo.inSafeMode && new UserChrome_js();"
        }
    ]
}