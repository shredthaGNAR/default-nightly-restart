{
    "sourceFile": "JS/verticalTabsPane.uc.js",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1651908296691,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1651908327630,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -2318,5 +2318,5 @@\n             }\r\n         };\r\n         Services.obs.addObserver(delayedListener, \"browser-delayed-startup-finished\");\r\n     }\r\n-})();\n\\ No newline at end of file\n+})\n\\ No newline at end of file\n"
                }
            ],
            "date": 1651908296691,
            "name": "Commit-0",
            "content": "// ==UserScript==\r\n// @name           Vertical Tabs Pane\r\n// @version        1.5.8\r\n// @author         aminomancer\r\n// @homepage       https://github.com/aminomancer/uc.css.js\r\n// @description    Create a vertical pane across from the sidebar that functions like the vertical\r\n// tab pane in Microsoft Edge. It doesn't hide the tab bar since people have different preferences\r\n// on how to do that, but it sets an attribute on the root element that you can use to hide the\r\n// regular tab bar while the vertical pane is open, for example :root[vertical-tabs] #TabsToolbar...\r\n// By default, the pane is resizable just like the sidebar is. And like the pane in Edge, you can\r\n// press a button to collapse it, and it will hide the tab labels and become a thin strip that just\r\n// shows the tabs' favicons. Hovering the collapsed pane will expand it without moving the browser\r\n// content. As with the [vertical-tabs] attribute, this \"unpinned\" state is reflected on the root\r\n// element, so you can select it like :root[vertical-tabs-unpinned]... Like the sidebar, the state\r\n// of the pane is stored between windows and recorded in preferences. There's no need to edit these\r\n// preferences directly. There are a few other preferences that can be edited in about:config, but\r\n// they can all be changed on the fly by opening the context menu within the pane. The new tab\r\n// button and the individual tabs all have their own context menus, but right-clicking anything else\r\n// will open the pane's context menu, which has options for changing these preferences. \"Move Pane\r\n// to Right/Left\" will change which side the pane (and by extension, the sidebar) is displayed on,\r\n// relative to the browser content. Since the pane always mirrors the position of the sidebar,\r\n// moving the pane to the right will move the sidebar to the left, and vice versa. \"Reverse Tab\r\n// Order\" changes the direction of the pane so that newer tabs are displayed on top rather than on\r\n// bottom. \"Expand Pane on Hover/Focus\" causes the pane to expand on hover when it's collapsed. When\r\n// you collapse the pane with the unpin button, it collapses to a small width and then temporarily\r\n// expands if you hover it, after a delay of 100ms. Then when your mouse leaves the pane, it\r\n// collapses again, after a delay of 100ms. Both of these delays can be changed with the \"Configure\r\n// Hover Delay\" and \"Configure Hover Out Delay\" options in the context menu, or in about:config. For\r\n// languages other than English, the labels and tooltips can be modified directly in the l10n object\r\n// below.\r\n// @license        This Source Code Form is subject to the terms of the Creative Commons Attribution-NonCommercial-ShareAlike International License, v. 4.0. If a copy of the CC BY-NC-SA 4.0 was not distributed with this file, You can obtain one at http://creativecommons.org/licenses/by-nc-sa/4.0/ or send a letter to Creative Commons, PO Box 1866, Mountain View, CA 94042, USA.\r\n// ==/UserScript==\r\n\r\n(function() {\r\n    let config = {\r\n        // localization strings. change these if your UI is not in english.\r\n        l10n: {\r\n            \"Button label\": `Vertical Tabs`, // label and tooltip for the toolbar button\r\n            \"Button tooltip\": `Toggle vertical tabs`,\r\n            \"Collapse button tooltip\": `Collapse pane`,\r\n            \"Pin button tooltip\": `Pin pane`,\r\n            // labels for the context menu\r\n            context: {\r\n                \"Move Pane to Right\": \"Move Pane to Right\",\r\n                \"Move Pane to Left\": \"Move Pane to Left\",\r\n                \"Expand Pane\": \"Expand Pane on Hover/Focus\",\r\n                \"Reverse Tab Order\": \"Reverse Tab Order\",\r\n                \"Configure Hover Delay\": \"Configure Hover Delay\",\r\n                \"Configure Hover Out Delay\": \"Configure Hover Out Delay\",\r\n            },\r\n            // strings for the hover delay config prompt\r\n            prompt: {\r\n                \"Hover delay title\": \"Hover delay (in milliseconds)\",\r\n                \"Hover delay description\": \"How long should the collapsed pane wait before expanding?\",\r\n                \"Hover out delay title\": \"Hover out delay (in milliseconds)\",\r\n                \"Hover out delay description\": \"How long should the expanded pane wait before collapsing?\",\r\n                \"Invalid\": \"Invalid input!\",\r\n                \"Invalid description\": \"This preference must be a positive integer.\",\r\n            },\r\n        },\r\n        // settings for the hotkey\r\n        hotkey: {\r\n            enabled: true, // set to false if you don't want any hotkey\r\n            modifiers: \"accel alt\", // valid modifiers are \"alt\", \"shift\", \"ctrl\", \"meta\" and \"accel\". accel is equal to ctrl on windows and linux, but meta (cmd âŒ˜) on macOS. meta is the windows key on windows. it's variable on linux.\r\n            key: \"V\", // the actual key. valid keys are letters, the hyphen key - and F1-F12. digits and F13-F24 are not supported by firefox.\r\n        },\r\n    };\r\n    if (location.href !== \"chrome://browser/content/browser.xhtml\") return;\r\n    let prefSvc = Services.prefs;\r\n    let closedPref = \"userChrome.tabs.verticalTabsPane.closed\";\r\n    let unpinnedPref = \"userChrome.tabs.verticalTabsPane.unpinned\";\r\n    let noExpandPref = \"userChrome.tabs.verticalTabsPane.no-expand-on-hover\";\r\n    let widthPref = \"userChrome.tabs.verticalTabsPane.width\";\r\n    let reversePref = \"userChrome.tabs.verticalTabsPane.reverse-order\";\r\n    let hoverDelayPref = \"userChrome.tabs.verticalTabsPane.hover-delay\";\r\n    let hoverOutDelayPref = \"userChrome.tabs.verticalTabsPane.hover-out-delay\";\r\n    let userContextPref = \"privacy.userContext.enabled\";\r\n    let containerOnClickPref = \"privacy.userContext.newTabContainerOnLeftClick.enabled\";\r\n    /**\r\n     * create a DOM node with given parameters\r\n     * @param {object} aDoc (which document to create the element in)\r\n     * @param {string} tag (an HTML tag name, like \"button\" or \"p\")\r\n     * @param {object} props (an object containing attribute name/value pairs, e.g. class: \".bookmark-item\")\r\n     * @param {boolean} isHTML (if true, create an HTML element. if omitted or false, create a XUL element. generally avoid HTML when modding the UI, most UI elements are actually XUL elements.)\r\n     * @returns the created DOM node\r\n     */\r\n    function create(aDoc, tag, props, isHTML = false) {\r\n        let el = isHTML ? aDoc.createElement(tag) : aDoc.createXULElement(tag);\r\n        for (let prop in props) {\r\n            el.setAttribute(prop, props[prop]);\r\n        }\r\n        return el;\r\n    }\r\n    /**\r\n     * set or remove multiple attributes for a given node\r\n     * @param {object} el (a DOM node)\r\n     * @param {object} attrs (an object of attribute name/value pairs)\r\n     * @returns the DOM node\r\n     */\r\n    function setAttributes(el, attrs) {\r\n        for (let [name, value] of Object.entries(attrs))\r\n            if (value) el.setAttribute(name, value);\r\n            else el.removeAttribute(name);\r\n    }\r\n    class VerticalTabsPaneBase {\r\n        static preferences = [\r\n            { name: closedPref, value: false },\r\n            { name: unpinnedPref, value: false },\r\n            { name: noExpandPref, value: false },\r\n            { name: widthPref, value: 350 },\r\n            { name: reversePref, value: false },\r\n            { name: hoverDelayPref, value: 100 },\r\n            { name: hoverOutDelayPref, value: 100 },\r\n        ];\r\n        constructor() {\r\n                this.preferences = VerticalTabsPaneBase.preferences;\r\n                this.registerSheet();\r\n                // ensure E10SUtils are available. required for showing tab's process ID in its tooltip, if the pref for that is enabled.\r\n                if (!window.E10SUtils)\r\n                    XPCOMUtils.defineLazyModuleGetters(this, {\r\n                        E10SUtils: \"resource://gre/modules/E10SUtils.jsm\",\r\n                    });\r\n                else this.E10SUtils = window.E10SUtils;\r\n                // get some localized strings for the tooltip\r\n                XPCOMUtils.defineLazyGetter(this, \"l10n\", function() {\r\n                    return new Localization([\"browser/browser.ftl\"], true);\r\n                });\r\n                this.formatFluentStrings();\r\n                Services.obs.addObserver(this, \"vertical-tabs-pane-toggle\");\r\n                // build the DOM\r\n                this.pane = document.getElementById(\"vertical-tabs-pane\");\r\n                this.splitter = document.getElementById(\"vertical-tabs-splitter\");\r\n                this.contextMenu = document.getElementById(\"mainPopupSet\").appendChild(\r\n                    create(document, \"menupopup\", {\r\n                        id: \"vertical-tabs-context-menu\",\r\n                    })\r\n                );\r\n                this.innerBox = this.pane.appendChild(\r\n                    create(document, \"vbox\", { id: \"vertical-tabs-inner-box\" })\r\n                );\r\n                this.buttonsRow = this.innerBox.appendChild(\r\n                    create(document, \"hbox\", {\r\n                        id: \"vertical-tabs-buttons-row\",\r\n                    })\r\n                );\r\n                this.contextMenu._menuitemPosition = this.contextMenu.appendChild(\r\n                    create(document, \"menuitem\", {\r\n                        id: \"vertical-tabs-context-position\",\r\n                        label: config.l10n.context[\"Move Pane to Right\"],\r\n                        oncommand: `Services.prefs.setBoolPref(SidebarUI.POSITION_START_PREF, true);`,\r\n                    })\r\n                );\r\n                this.contextMenu._menuitemExpand = this.contextMenu.appendChild(\r\n                    create(document, \"menuitem\", {\r\n                        id: \"vertical-tabs-context-expand\",\r\n                        label: config.l10n.context[\"Expand Pane\"],\r\n                        type: \"checkbox\",\r\n                        oncommand: `Services.prefs.setBoolPref(\"userChrome.tabs.verticalTabsPane.no-expand-on-hover\", !this.getAttribute(\"checked\"));`,\r\n                    })\r\n                );\r\n                this.contextMenu._menuitemReverse = this.contextMenu.appendChild(\r\n                    create(document, \"menuitem\", {\r\n                        id: \"vertical-tabs-context-reverse\",\r\n                        label: config.l10n.context[\"Reverse Tab Order\"],\r\n                        type: \"checkbox\",\r\n                        oncommand: `Services.prefs.setBoolPref(\"userChrome.tabs.verticalTabsPane.reverse-order\", this.getAttribute(\"checked\"));`,\r\n                    })\r\n                );\r\n                this.contextMenu._menuitemHoverDelay = this.contextMenu.appendChild(\r\n                    create(document, \"menuitem\", {\r\n                        id: \"vertical-tabs-context-hover-delay\",\r\n                        label: config.l10n.context[\"Configure Hover Delay\"],\r\n                        oncommand: `verticalTabsPane.promptForIntPref(\"userChrome.tabs.verticalTabsPane.hover-delay\")`,\r\n                    })\r\n                );\r\n                this.contextMenu._menuitemHoverOutDelay = this.contextMenu.appendChild(\r\n                    create(document, \"menuitem\", {\r\n                        id: \"vertical-tabs-context-hover-out-delay\",\r\n                        label: config.l10n.context[\"Configure Hover Out Delay\"],\r\n                        oncommand: `verticalTabsPane.promptForIntPref(\"userChrome.tabs.verticalTabsPane.hover-out-delay\")`,\r\n                    })\r\n                );\r\n                // tab stops let us focus elements in the tabs pane by hitting tab to cycle through toolbars, just as in vanilla firefox.\r\n                this.buttonsTabStop = this.buttonsRow.appendChild(\r\n                    create(document, \"toolbartabstop\", { \"aria-hidden\": true })\r\n                );\r\n                this.newTabButton = this.buttonsRow.appendChild(\r\n                    document.getElementById(\"new-tab-button\").cloneNode(true)\r\n                );\r\n                this.newTabButton.id = \"vertical-tabs-new-tab-button\";\r\n                this.newTabButton.setAttribute(\"flex\", \"1\");\r\n                this.newTabButton.setAttribute(\"class\", \"subviewbutton subviewbutton-iconic\");\r\n                nodeToShortcutMap[this.newTabButton.id] = nodeToShortcutMap[\"new-tab-button\"];\r\n                this.pinPaneButton = this.buttonsRow.appendChild(\r\n                    create(document, \"toolbarbutton\", {\r\n                        id: \"vertical-tabs-pin-button\",\r\n                        class: \"subviewbutton subviewbutton-iconic no-label\",\r\n                        tooltiptext: config.l10n[\"Collapse button tooltip\"],\r\n                    })\r\n                );\r\n                this.pinPaneButton.addEventListener(\"command\", (e) => {\r\n                    this.pane.getAttribute(\"unpinned\") ?\r\n                        this.pane.removeAttribute(\"unpinned\") :\r\n                        this.unpin();\r\n                    this.resetPinnedTooltip();\r\n                });\r\n                this.closePaneButton = this.buttonsRow.appendChild(\r\n                    create(document, \"toolbarbutton\", {\r\n                        id: \"vertical-tabs-close-button\",\r\n                        class: \"subviewbutton subviewbutton-iconic no-label\",\r\n                        tooltiptext: config.l10n[\"Button tooltip\"],\r\n                    })\r\n                );\r\n                if (key_toggleVerticalTabs)\r\n                    this.closePaneButton.tooltipText += ` (${ShortcutUtils.prettifyShortcut(\r\n                    key_toggleVerticalTabs\r\n                )})`;\r\n                this.closePaneButton.addEventListener(\"command\", (e) => this.toggle());\r\n                this.innerBox.appendChild(create(document, \"toolbarseparator\"));\r\n                this.scrollboxTabStop = this.innerBox.appendChild(\r\n                    create(document, \"toolbartabstop\", { \"aria-hidden\": true })\r\n                );\r\n                this.containerNode = this.innerBox.appendChild(\r\n                    create(document, \"arrowscrollbox\", {\r\n                        id: \"vertical-tabs-list\",\r\n                        tooltip: \"vertical-tabs-tooltip\",\r\n                        context: \"tabContextMenu\",\r\n                        orient: \"vertical\",\r\n                        flex: \"1\",\r\n                    })\r\n                );\r\n                // build a modified clone of the built-in tabs tooltip for use in the pane.\r\n                let vanillaTooltip = document.getElementById(\"tabbrowser-tab-tooltip\");\r\n                this.tabTooltip = vanillaTooltip.cloneNode(true);\r\n                vanillaTooltip.after(this.tabTooltip);\r\n                this.tabTooltip.id = \"vertical-tabs-tooltip\";\r\n                this.tabTooltip.setAttribute(\r\n                    \"onpopupshowing\",\r\n                    `verticalTabsPane.createTabTooltip(event)`\r\n                );\r\n                // this is a map of all the rows, and you can get a specific row from it by passing a tab (like a real <tab> element from the built-in tab bar)\r\n                this.tabToElement = new Map();\r\n                this.listenersRegistered = false;\r\n                // set up preferences if they don't already exist\r\n                this.preferences.forEach((pref) => {\r\n                    if (!prefSvc.prefHasUserValue(pref.name))\r\n                        prefSvc[`set${typeof pref.value === \"number\" ? \"Int\" : \"Bool\"}Pref`](\r\n                            pref.name,\r\n                            pref.value\r\n                        );\r\n                });\r\n                prefSvc.addObserver(\"userChrome.tabs.verticalTabsPane\", this);\r\n                prefSvc.addObserver(\"privacy.userContext\", this);\r\n                prefSvc.addObserver(SidebarUI.POSITION_START_PREF, this);\r\n                // re-initialize the sidebar's positionstart pref callback since we changed it earlier at the bottom to make it also move the vertical tabs pane.\r\n                XPCOMUtils.defineLazyPreferenceGetter(\r\n                    SidebarUI,\r\n                    \"_positionStart\",\r\n                    SidebarUI.POSITION_START_PREF,\r\n                    true,\r\n                    SidebarUI.setPosition.bind(SidebarUI)\r\n                );\r\n                // destroy the scrollbuttons.\r\n                [\"#scrollbutton-up\", \"#scrollbutton-down\"].forEach((id) =>\r\n                    this.containerNode.shadowRoot.querySelector(id).remove()\r\n                );\r\n                this.l10nIfNeeded();\r\n                // the pref observer changes stuff in the script when the pref is changed.\r\n                // but when the script initially starts, the prefs haven't been changed so that logic isn't immediately invoked.\r\n                // we have to invoke it manually, as if the prefs had been changed.\r\n                let readPref = (pref) => this.observe(prefSvc, \"nsPref:read\", pref);\r\n                readPref(noExpandPref);\r\n                readPref(hoverDelayPref);\r\n                readPref(hoverOutDelayPref);\r\n                if (!this.hoverDelay) this.hoverDelay = 100;\r\n                if (!this.hoverOutDelay) this.hoverOutDelay = 100;\r\n                // we don't want to read some of these prefs until we know whether the window was opened by another window with a pane,\r\n                // because instead of reading from prefs we can adopt the pane state from the previous window.\r\n                // normally in my scripts I update prefs like this every time they're changed, which would mean, for example,\r\n                // changing the pane's width in one window would instantly update the pane's width in every other window.\r\n                // that's not how firefox's built-in sidebar works, though. when you open a window, the sidebar state is taken from the previous window.\r\n                // but changing the sidebar in that window won't affect the sidebar in the previous window.\r\n                // sidebar state isn't permanently stored anywhere until the last window is closed. (basically, when the app has been closed)\r\n                // so to keep this consistent with the sidebar we're gonna use the previous window as the main source of state, and use prefs as a fallback.\r\n                // the prefs will be set when the last window is closed (see the uninit function at the bottom)\r\n                SessionStore.promiseInitialized.then(() => {\r\n                    if (window.closed) return;\r\n                    readPref(reversePref);\r\n                    readPref(userContextPref);\r\n                    readPref(SidebarUI.POSITION_START_PREF);\r\n                    // try to adopt from previous window, otherwise restore from prefs.\r\n                    let sourceWindow = window.opener;\r\n                    if (sourceWindow)\r\n                        if (!sourceWindow.closed && sourceWindow.location.protocol == \"chrome:\")\r\n                            if (this.adoptFromWindow(sourceWindow)) return;\r\n                    readPref(widthPref);\r\n                    readPref(unpinnedPref);\r\n                    readPref(closedPref);\r\n                });\r\n            }\r\n            // get the root element, e.g. what you'd select in CSS with :root\r\n        get root() {\r\n                return this._root || (this._root = document.documentElement);\r\n            }\r\n            // return all the DOM nodes for tab rows in the pane.\r\n        get rows() {\r\n                return this.tabToElement.values();\r\n            }\r\n            // return the row for the active/selected tab.\r\n        get selectedRow() {\r\n                return this.containerNode.querySelector(\".all-tabs-item[selected]\");\r\n            }\r\n            // all of these events will be listened for on the pane itself\r\n        get paneEvents() {\r\n                return this._paneEvents || (this._paneEvents = [\"mouseenter\", \"mouseleave\", \"focus\"]);\r\n            }\r\n            // these events target the containerNode â€” the arrowscrollbox\r\n        get dragEvents() {\r\n                return (\r\n                    this._dragEvents ||\r\n                    (this._dragEvents = [\"dragstart\", \"dragleave\", \"dragover\", \"drop\", \"dragend\"])\r\n                );\r\n            }\r\n            // these events target the vanilla tab bar, gBrowser.tabContainer\r\n        get tabEvents() {\r\n                return (\r\n                    this._tabEvents ||\r\n                    (this._tabEvents = [\r\n                        \"TabAttrModified\",\r\n                        \"TabClose\",\r\n                        \"TabMove\",\r\n                        \"TabHide\",\r\n                        \"TabShow\",\r\n                        \"TabPinned\",\r\n                        \"TabUnpinned\",\r\n                        \"TabSelect\",\r\n                        \"TabBrowserDiscarded\",\r\n                    ])\r\n                );\r\n            }\r\n            // this creates (and caches) a tree walker. tree walkers are basically interfaces for finding nodes in order.\r\n            // we get to specify which direction we're looking in, forward or backward, and we get to specify a filter function that rules out types of elements.\r\n            // this one accepts tabstops, buttons, toolbarbuttons, and checkboxes, but rules out disabled or hidden nodes, and rules out everything else.\r\n            // this is what tells us which element to focus when pressing the right/left arrow keys.\r\n        get horizontalWalker() {\r\n                if (this._horizontalWalker) return this._horizontalWalker;\r\n                return (this._horizontalWalker = document.createTreeWalker(\r\n                    this.pane,\r\n                    NodeFilter.SHOW_ELEMENT,\r\n                    (node) => {\r\n                        if (node.tagName == \"toolbartabstop\") return NodeFilter.FILTER_ACCEPT;\r\n                        if (node.disabled || node.hidden) return NodeFilter.FILTER_REJECT;\r\n                        if (\r\n                            node.tagName == \"button\" ||\r\n                            node.tagName == \"toolbarbutton\" ||\r\n                            node.tagName == \"checkbox\"\r\n                        ) {\r\n                            if (!node.hasAttribute(\"tabindex\")) node.setAttribute(\"tabindex\", \"-1\");\r\n                            return NodeFilter.FILTER_ACCEPT;\r\n                        }\r\n                        return NodeFilter.FILTER_SKIP;\r\n                    }\r\n                ));\r\n            }\r\n            // this one tells us which element to focus when pressing the up/down arrow keys.\r\n            // it's just like the other but it skips secondary buttons. (mute and close buttons)\r\n            // this way we can arrow up/down to navigate through tabs very quickly, and arrow left/right to focus the mute and close buttons.\r\n        get verticalWalker() {\r\n                if (this._verticalWalker) return this._verticalWalker;\r\n                return (this._verticalWalker = document.createTreeWalker(\r\n                    this.pane,\r\n                    NodeFilter.SHOW_ELEMENT,\r\n                    (node) => {\r\n                        if (node.tagName == \"toolbartabstop\") return NodeFilter.FILTER_ACCEPT;\r\n                        if (node.disabled || node.hidden) return NodeFilter.FILTER_REJECT;\r\n                        if (\r\n                            node.tagName == \"button\" ||\r\n                            node.tagName == \"toolbarbutton\" ||\r\n                            node.tagName == \"checkbox\"\r\n                        ) {\r\n                            if (node.classList.contains(\"all-tabs-secondary-button\"))\r\n                                return NodeFilter.FILTER_SKIP;\r\n                            if (!node.hasAttribute(\"tabindex\")) node.setAttribute(\"tabindex\", \"-1\");\r\n                            return NodeFilter.FILTER_ACCEPT;\r\n                        }\r\n                        return NodeFilter.FILTER_SKIP;\r\n                    }\r\n                ));\r\n            }\r\n            // make an array containing all the context menus that can be opened by right-clicking something inside the pane.\r\n        get contextMenus() {\r\n                let menus = [];\r\n                let contextDefs = [...this.pane.querySelectorAll(\"[context]\")];\r\n                contextDefs.push(this.pane);\r\n                contextDefs.forEach((node) => {\r\n                    let menu = document.getElementById(node.getAttribute(\"context\"));\r\n                    if (menus.indexOf(menu) === -1) menus.push(menu);\r\n                });\r\n                return menus;\r\n            }\r\n            // we want to prevent the pane from collapsing when a context menu is opened from inside it.\r\n            // since document.popupNode was recently removed, we have to manually locate every context menu,\r\n            // and check if it's open by checking the triggerNode property. if the triggerNode is inside the pane,\r\n            // we prevent the pane from collapsing and instead add a popuphidden event listener,\r\n            // so it instead collapses once the pane has been closed.\r\n            // imo this is a good reason to bring document.popupNode back, but I don't have any power over that.\r\n        get openMenu() {\r\n                let menus = this.contextMenus;\r\n                if (!menus.length) return false;\r\n                let openMenu = false;\r\n                menus.forEach((menu) => {\r\n                    if (menu.triggerNode && this.pane.contains(menu.triggerNode)) openMenu = menu;\r\n                });\r\n                return openMenu;\r\n            }\r\n            // grab the localized strings for the built-in tab sound pseudo-tooltip, e.g. \"PLAYING\" or \"AUTOPLAY BLOCKED\".\r\n            // we lowercase these and append them to the end of the tooltip title if the sound overlay is hovered.\r\n        async formatFluentStrings() {\r\n                let [playingString, mutedString, blockedString, pipString] =\r\n                await this.l10n.formatValues([\r\n                    \"browser-tab-audio-playing2\",\r\n                    \"browser-tab-audio-muted2\",\r\n                    \"browser-tab-audio-blocked\",\r\n                    \"browser-tab-audio-pip\",\r\n                ]);\r\n                this.fluentStrings = {\r\n                    playingString,\r\n                    mutedString,\r\n                    blockedString,\r\n                    pipString,\r\n                };\r\n            }\r\n            /**\r\n             * this tells us which tabs to not make rows for. in this case we only exclude hidden tabs.\r\n             * tabs are normally only hidden by certain extensions, e.g. an addon that makes tab groups.\r\n             * @param {object} tab (a <tab> element from the vanilla tab bar)\r\n             * @returns {boolean} false if the tab should be excluded from the vertical tabs pane\r\n             */\r\n        filterFn(tab) {\r\n                return !tab.hidden;\r\n            }\r\n            /**\r\n             * get the initial state for the pane from a previous window. this is what happens when you open a new window (not the first window of a session)\r\n             * @param {object} sourceWindow (a window object, the window from which the new window was opened)\r\n             * @returns {boolean} true if state was successfully restored from source window, false if state must be restored from preferences.\r\n             */\r\n        adoptFromWindow(sourceWindow) {\r\n                let sourceUI = sourceWindow.verticalTabsPane;\r\n                if (!sourceUI || !sourceUI.pane) return false;\r\n                this.pane.setAttribute(\r\n                    \"width\",\r\n                    sourceUI.pane.width || sourceUI.pane.getBoundingClientRect().width\r\n                );\r\n                let sourcePinned = !!sourceUI.pane.getAttribute(\"unpinned\");\r\n                sourcePinned ? this.unpin() : this.pane.removeAttribute(\"unpinned\");\r\n                sourcePinned\r\n                    ?\r\n                    this.root.setAttribute(\"vertical-tabs-unpinned\", true) :\r\n                    this.root.removeAttribute(\"vertical-tabs-unpinned\");\r\n                this.resetPinnedTooltip();\r\n                sourceUI.pane.hidden ? this.close() : this.open();\r\n                return true;\r\n            }\r\n            /**\r\n             * for a given descendant of a tab row, return the actual tab row element.\r\n             * @param {object} el (a DOM node contained within a tab row)\r\n             * @returns the ancestor tab row\r\n             */\r\n        findRow(el) {\r\n                return el.classList.contains(\"all-tabs-item\") ? el : el.closest(\".all-tabs-item\");\r\n            }\r\n            // change the pin/unpin button's tooltip so it reflects the current state.\r\n            // if the pane is pinned, the button should say \"Collapse pane\" and if it's unpinned it should say \"Pin pane\"\r\n        resetPinnedTooltip() {\r\n                let newVal = this.pane.getAttribute(\"unpinned\");\r\n                this.pinPaneButton.tooltipText =\r\n                    config.l10n[newVal ? \"Pin button tooltip\" : \"Collapse button tooltip\"];\r\n            }\r\n            /**\r\n             * launch a modal prompt (attached to the window) asking the user to set the hover/hover out delay.\r\n             * the prompt has an input box containing the current value. it will accept any positive integer.\r\n             * this is invoked by the \"configure hover delay\" context menu items.\r\n             * @param {string} pref (which pref the prompt should change)\r\n             * @returns an error prompt if the input is invalid, which returns back to this input prompt\r\n             */\r\n        promptForIntPref(pref) {\r\n                let val, title, text;\r\n                switch (pref) {\r\n                    case hoverDelayPref:\r\n                        val = this.hoverDelay ? ? 100;\r\n                        title = config.l10n.prompt[\"Hover delay title\"];\r\n                        text = config.l10n.prompt[\"Hover delay description\"];\r\n                        break;\r\n                    case hoverOutDelayPref:\r\n                        val = this.hoverOutDelay ? ? 100;\r\n                        title = config.l10n.prompt[\"Hover out delay title\"];\r\n                        text = config.l10n.prompt[\"Hover out delay description\"];\r\n                        break;\r\n                }\r\n                let input = { value: val };\r\n                let win = Services.wm.getMostRecentWindow(null);\r\n                let ok = Services.prompt.prompt(win, title, text, input, null, { value: 0 });\r\n                if (!ok) return;\r\n                let int = parseInt(input.value, 10);\r\n                let onFail = () => {\r\n                    Services.prompt.alert(\r\n                        win,\r\n                        config.l10n.prompt.Invalid,\r\n                        config.l10n.prompt[\"Invalid description\"]\r\n                    );\r\n                    this.promptForIntPref(pref);\r\n                };\r\n                if (!(int >= 0)) return onFail();\r\n                else\r\n                    try {\r\n                        prefSvc.setIntPref(pref, int);\r\n                    } catch (e) {\r\n                        return onFail();\r\n                    }\r\n            }\r\n            /**\r\n             * universal event handler â€” we generally pass the whole class to addEventListener and let this function decide which callback to invoke.\r\n             * @param {object} e (an event object)\r\n             */\r\n        handleEvent(e) {\r\n                let { tab } = e.target;\r\n                switch (e.type) {\r\n                    case \"mousedown\":\r\n                        this._onMouseDown(e, tab);\r\n                        break;\r\n                    case \"mouseup\":\r\n                        this._onMouseUp(e, tab);\r\n                        break;\r\n                    case \"click\":\r\n                        this._onClick(e);\r\n                        break;\r\n                    case \"command\":\r\n                        this._onCommand(e, tab);\r\n                        break;\r\n                    case \"mouseover\":\r\n                        this.warmupRowTab(e, tab);\r\n                        break;\r\n                    case \"mouseenter\":\r\n                        this._onMouseEnter(e);\r\n                        break;\r\n                    case \"mouseleave\":\r\n                        this._onMouseLeave(e);\r\n                        break;\r\n                    case \"deactivate\":\r\n                        this._onDeactivate(e);\r\n                        break;\r\n                    case \"TabHide\":\r\n                    case \"TabShow\":\r\n                    case \"TabPinned\":\r\n                    case \"TabUnpinned\":\r\n                    case \"TabAttrModified\":\r\n                    case \"TabBrowserDiscarded\":\r\n                        this._tabAttrModified(e.target);\r\n                        break;\r\n                    case \"TabClose\":\r\n                        this._tabClose(e.target);\r\n                        break;\r\n                    case \"TabMove\":\r\n                        this._moveTab(e.target);\r\n                        break;\r\n                    case \"dragstart\":\r\n                        this._onDragStart(e, tab);\r\n                        break;\r\n                    case \"dragleave\":\r\n                        this._onDragLeave(e);\r\n                        break;\r\n                    case \"dragover\":\r\n                        this._onDragOver(e);\r\n                        break;\r\n                    case \"dragend\":\r\n                        this._onDragEnd(e);\r\n                        break;\r\n                    case \"drop\":\r\n                        this._onDrop(e);\r\n                        break;\r\n                    case \"keydown\":\r\n                        this._onKeyDown(e);\r\n                        break;\r\n                    case \"focus\":\r\n                        this._onFocus(e);\r\n                        break;\r\n                    case \"blur\":\r\n                        e.currentTarget === this.pane ? this._onPaneBlur(e) : this._onButtonBlur(e);\r\n                        break;\r\n                    case \"TabMultiSelect\":\r\n                        this._onTabMultiSelect();\r\n                        break;\r\n                    case \"TabSelect\":\r\n                        if (this.isOpen)\r\n                            this.tabToElement.get(e.target).scrollIntoView({ block: \"nearest\" });\r\n                        break;\r\n                }\r\n            }\r\n            /**\r\n             * notification observer. used to receive notifications about prefs changing, or notifications telling us to toggle the pane\r\n             * @param {object} subject (the subject of the notification)\r\n             * @param {string} topic (the topic \"nsPref:changed\" is passed to our observer when a pref is changed. we use \"vertical-tabs-pane-toggle\" to toggle the pane)\r\n             * @param {string} data (additional data is often passed, e.g. the name of the preference that changed)\r\n             */\r\n        observe(subject, topic, data) {\r\n                switch (topic) {\r\n                    case \"vertical-tabs-pane-toggle\":\r\n                        if (subject === window) this.toggle();\r\n                        break;\r\n                    case \"nsPref:changed\":\r\n                    case \"nsPref:read\":\r\n                        this._onPrefChanged(subject, data);\r\n                        break;\r\n                }\r\n            }\r\n            /**\r\n             * for a given preference, get its value, regardless of the preference type.\r\n             * @param {object} root (an object with nsIPrefBranch interface â€” reflects the preference branch we're watching, or just the root)\r\n             * @param {string} pref (a preference string)\r\n             * @returns the preference's value\r\n             */\r\n        getPref(root, pref) {\r\n                switch (root.getPrefType(pref)) {\r\n                    case root.PREF_BOOL:\r\n                        return root.getBoolPref(pref);\r\n                    case root.PREF_INT:\r\n                        return root.getIntPref(pref);\r\n                    case root.PREF_STRING:\r\n                        return root.getStringPref(pref);\r\n                    default:\r\n                        return null;\r\n                }\r\n            }\r\n            /**\r\n             * universal preference observer. when a preference is changed, do something about it.\r\n             * @param {object} sub (an object with nsIPrefBranch interface â€” reflects the preference branch we're watching, or just the root)\r\n             * @param {string} pref (the preference that changed)\r\n             */\r\n        _onPrefChanged(sub, pref) {\r\n            let value = this.getPref(sub, pref);\r\n            switch (pref) {\r\n                case widthPref:\r\n                    if (value === null) value = 350;\r\n                    this.pane.width = value;\r\n                    break;\r\n                case closedPref:\r\n                    value ? this.close() : this.open();\r\n                    break;\r\n                case unpinnedPref:\r\n                    value ? this.unpin() : this.pane.removeAttribute(\"unpinned\");\r\n                    value\r\n                        ?\r\n                        this.root.setAttribute(\"vertical-tabs-unpinned\", true) :\r\n                        this.root.removeAttribute(\"vertical-tabs-unpinned\");\r\n                    this.resetPinnedTooltip();\r\n                    break;\r\n                case noExpandPref:\r\n                    this.noExpand = value;\r\n                    if (value) {\r\n                        this.pane.setAttribute(\"no-expand\", true);\r\n                        this.pane.removeAttribute(\"expanded\");\r\n                        this.contextMenu._menuitemExpand.removeAttribute(\"checked\");\r\n                    } else {\r\n                        this.pane.removeAttribute(\"no-expand\");\r\n                        this.contextMenu._menuitemExpand.setAttribute(\"checked\", true);\r\n                    }\r\n                    break;\r\n                case reversePref:\r\n                    this.reversed = value;\r\n                    if (this.isOpen) {\r\n                        for (let item of this.rows) item.remove();\r\n                        this.tabToElement = new Map();\r\n                        this._populate();\r\n                    }\r\n                    if (value) this.contextMenu._menuitemReverse.setAttribute(\"checked\", true);\r\n                    else this.contextMenu._menuitemReverse.removeAttribute(\"checked\");\r\n                    break;\r\n                case hoverDelayPref:\r\n                    this.hoverDelay = value ? ? 100;\r\n                    break;\r\n                case hoverOutDelayPref:\r\n                    this.hoverOutDelay = value ? ? 100;\r\n                    break;\r\n                case userContextPref:\r\n                case containerOnClickPref:\r\n                    this.handlePrivacyChange();\r\n                    break;\r\n                case SidebarUI.POSITION_START_PREF:\r\n                    let menuitem = this.contextMenu._menuitemPosition;\r\n                    if (value) {\r\n                        menuitem.label = config.l10n.context[\"Move Pane to Left\"];\r\n                        menuitem.setAttribute(\r\n                            \"oncommand\",\r\n                            `Services.prefs.setBoolPref(SidebarUI.POSITION_START_PREF, false);`\r\n                        );\r\n                    } else {\r\n                        menuitem.label = config.l10n.context[\"Move Pane to Right\"];\r\n                        menuitem.setAttribute(\r\n                            \"oncommand\",\r\n                            `Services.prefs.setBoolPref(SidebarUI.POSITION_START_PREF, true);`\r\n                        );\r\n                    }\r\n                    break;\r\n            }\r\n        }\r\n        toggle() {\r\n            this.isOpen ? this.close() : this.open();\r\n        }\r\n        open() {\r\n            this.pane.hidden = this.splitter.hidden = false;\r\n            this.pane.setAttribute(\"checked\", true);\r\n            this.isOpen = true;\r\n            this.root.setAttribute(\"vertical-tabs\", true);\r\n            if (!this.listenersRegistered) this._populate();\r\n        }\r\n        close() {\r\n                if (this.pane.contains(document.activeElement)) document.activeElement.blur();\r\n                this.pane.hidden = this.splitter.hidden = true;\r\n                this.pane.removeAttribute(\"checked\");\r\n                this.isOpen = false;\r\n                this.root.setAttribute(\"vertical-tabs\", false);\r\n                this._cleanup();\r\n            }\r\n            // set the active tab\r\n        _selectTab(tab) {\r\n                if (gBrowser.selectedTab != tab) gBrowser.selectedTab = tab;\r\n                else gBrowser.tabContainer._handleTabSelect();\r\n            }\r\n            // fill the pane with tab rows\r\n        _populate() {\r\n                let fragment = document.createDocumentFragment();\r\n                for (let tab of gBrowser.tabs)\r\n                    if (this.filterFn(tab))\r\n                        fragment[this.reversed ? `prepend` : `appendChild`](this._createRow(tab));\r\n                this._addElement(fragment);\r\n                this._setupListeners();\r\n                for (let row of this.rows) this._setImageAttributes(row, row.tab);\r\n                this.selectedRow.scrollIntoView({ block: \"nearest\", behavior: \"instant\" });\r\n            }\r\n            /**\r\n             * add an element to the tab container/arrowscrollbox\r\n             * @param {object} elementOrFragment (a DOM element or document fragment to add to the container)\r\n             */\r\n        _addElement(elementOrFragment) {\r\n                this.containerNode.insertBefore(elementOrFragment, this.insertBefore);\r\n            }\r\n            // invoked when closing the pane. set everything back to default.\r\n        _cleanup() {\r\n                for (let item of this.rows) item.remove();\r\n                this.tabToElement = new Map();\r\n                this._cleanupListeners();\r\n                clearTimeout(this.hoverOutTimer);\r\n                clearTimeout(this.hoverTimer);\r\n                this.hoverOutQueued = false;\r\n                this.hoverQueued = false;\r\n                this.pane.removeAttribute(\"expanded\");\r\n            }\r\n            // invoked when opening the pane. add all the event listeners.\r\n            // this way the script is less wasteful when the pane is closed.\r\n        _setupListeners() {\r\n                this.listenersRegistered = true;\r\n                window.addEventListener(\"deactivate\", this);\r\n                this.tabEvents.forEach((ev) => gBrowser.tabContainer.addEventListener(ev, this));\r\n                this.dragEvents.forEach((ev) => this.containerNode.addEventListener(ev, this));\r\n                this.paneEvents.forEach((ev) => this.pane.addEventListener(ev, this));\r\n                if (gToolbarKeyNavEnabled) this.pane.addEventListener(\"keydown\", this);\r\n                this.pane.addEventListener(\"blur\", this, true);\r\n                gBrowser.addEventListener(\"TabMultiSelect\", this, false);\r\n                for (let stop of this.pane.getElementsByTagName(\"toolbartabstop\"))\r\n                    stop.addEventListener(\"focus\", this);\r\n            }\r\n            // invoked when closing the pane. clear all the aforementioned event listeners.\r\n        _cleanupListeners() {\r\n                window.removeEventListener(\"deactivate\", this);\r\n                this.tabEvents.forEach((ev) => gBrowser.tabContainer.removeEventListener(ev, this));\r\n                this.dragEvents.forEach((ev) => this.containerNode.removeEventListener(ev, this));\r\n                this.paneEvents.forEach((ev) => this.pane.removeEventListener(ev, this));\r\n                this.pane.removeEventListener(\"keydown\", this);\r\n                this.pane.removeEventListener(\"blur\", this, true);\r\n                gBrowser.removeEventListener(\"TabMultiSelect\", this, false);\r\n                for (let stop of this.pane.getElementsByTagName(\"toolbartabstop\"))\r\n                    stop.removeEventListener(\"focus\", this);\r\n                this.listenersRegistered = false;\r\n            }\r\n            /**\r\n             * callback when a tab attribute is modified. a response to the TabAttrModified custom event dispatched by gBrowser.\r\n             * this is what we use to update most of the tab attributes, like busy, soundplaying, etc.\r\n             * @param {object} tab (a tab element from the real tab bar)\r\n             */\r\n        _tabAttrModified(tab) {\r\n                let item = this.tabToElement.get(tab);\r\n                if (item) {\r\n                    if (!this.filterFn(tab)) this._removeItem(item, tab);\r\n                    else this._setRowAttributes(item, tab);\r\n                } else if (this.filterFn(tab)) this._addTab(tab);\r\n            }\r\n            /**\r\n             * the key implies that we're moving a tab, but this doesn't tell us where to move the tab to.\r\n             * in reality, this just removes a tab and adds it back. it simply gets called when a tab gets moved by other means,\r\n             * so we delete the row and _addTab places it in the same position as its corresponding tab.\r\n             * meaning we can't actually move a tab this way, this just helps the tabs pane mirror the real tab bar.\r\n             * @param {object} tab (a tab element)\r\n             */\r\n        _moveTab(tab) {\r\n                let item = this.tabToElement.get(tab);\r\n                if (item) {\r\n                    this._removeItem(item, tab);\r\n                    this._addTab(tab);\r\n                    this.selectedRow.scrollIntoView({ block: \"nearest\", behavior: \"instant\" });\r\n                }\r\n            }\r\n            /**\r\n             * invoked by the above functions. if a tab's attributes change and it's somehow not in the pane already, add it.\r\n             * this adds a dom node for a given tab and places it in a position reflecting the tab's real position.\r\n             * @param {object} newTab (a tab element that's not already in the pane)\r\n             */\r\n        _addTab(newTab) {\r\n                if (!this.filterFn(newTab)) return;\r\n                let newRow = this._createRow(newTab);\r\n                let nextTab = newTab.nextElementSibling;\r\n                while (nextTab && !this.filterFn(nextTab)) nextTab = nextTab.nextElementSibling;\r\n                let nextRow = this.tabToElement.get(nextTab);\r\n                if (this.reversed) {\r\n                    if (nextRow) nextRow.after(newRow);\r\n                    else this.containerNode.prepend(newRow);\r\n                } else {\r\n                    if (nextRow) nextRow.parentNode.insertBefore(newRow, nextRow);\r\n                    else this._addElement(newRow);\r\n                }\r\n            }\r\n            /**\r\n             * invoked when a tab is closed from outside the pane. since the tab no longer exists, remove it from the pane.\r\n             * @param {object} tab (a tab element)\r\n             */\r\n        _tabClose(tab) {\r\n                let item = this.tabToElement.get(tab);\r\n                if (item) this._removeItem(item, tab);\r\n            }\r\n            /**\r\n             * remove a tab/item pair from the map, and remove the item from the DOM.\r\n             * @param {object} item (a row element, e.g. with class all-tabs-item)\r\n             * @param {object} tab (a corresponding tab element â€” every all-tabs-item has a reference to its corresponding tab in property \"tab\")\r\n             */\r\n        _removeItem(item, tab) {\r\n                this.tabToElement.delete(tab);\r\n                item.remove();\r\n            }\r\n            /**\r\n             * for a given tab, create a row in the pane's container.\r\n             * @param {object} tab (a tab element)\r\n             * @returns a row element\r\n             */\r\n        _createRow(tab) {\r\n                let row = create(document, \"toolbaritem\", {\r\n                    class: \"all-tabs-item\",\r\n                    draggable: true,\r\n                });\r\n                if (this.className) row.classList.add(this.className);\r\n                row.tab = tab;\r\n                row.addEventListener(\"command\", this);\r\n                row.addEventListener(\"mousedown\", this);\r\n                row.addEventListener(\"mouseup\", this);\r\n                row.addEventListener(\"click\", this);\r\n                row.addEventListener(\"mouseover\", this);\r\n                this.tabToElement.set(tab, row);\r\n\r\n                // main button\r\n                row.mainButton = row.appendChild(\r\n                    create(document, \"toolbarbutton\", {\r\n                        class: \"all-tabs-button subviewbutton subviewbutton-iconic\",\r\n                        flex: \"1\",\r\n                        crop: \"right\",\r\n                    })\r\n                );\r\n                row.mainButton.tab = tab;\r\n\r\n                // audio button\r\n                row.audioButton = row.appendChild(\r\n                    create(document, \"toolbarbutton\", {\r\n                        class: \"all-tabs-secondary-button subviewbutton subviewbutton-iconic\",\r\n                        closemenu: \"none\",\r\n                        \"toggle-mute\": \"true\",\r\n                    })\r\n                );\r\n                row.audioButton.tab = tab;\r\n\r\n                // close button\r\n                row.closeButton = row.appendChild(\r\n                    create(document, \"toolbarbutton\", {\r\n                        class: \"all-tabs-secondary-button subviewbutton subviewbutton-iconic\",\r\n                        \"close-button\": \"true\",\r\n                    })\r\n                );\r\n                row.closeButton.tab = tab;\r\n\r\n                // sound overlay â€” it only shows when the pane is collapsed\r\n                row.soundOverlay = row.appendChild(\r\n                    create(document, \"image\", { class: \"sound-overlay\" }, true)\r\n                );\r\n                row.soundOverlay.tab = tab;\r\n\r\n                this._setRowAttributes(row, tab);\r\n                return row;\r\n            }\r\n            /**\r\n             * for a given row/tab pair, set the row's attributes equal to the tab's.\r\n             * this gets invoked on various events whereupon we need to update a row's display\r\n             * @param {object} row (a row element)\r\n             * @param {object} tab (a tab element)\r\n             */\r\n        _setRowAttributes(row, tab) {\r\n                // attributes to set on the row\r\n                setAttributes(row, {\r\n                    selected: tab.selected,\r\n                    pinned: tab.pinned,\r\n                    pending: tab.getAttribute(\"pending\"),\r\n                    multiselected: tab.getAttribute(\"multiselected\"),\r\n                    muted: tab.muted,\r\n                    soundplaying: tab.soundPlaying,\r\n                    \"activemedia-blocked\": tab.activeMediaBlocked,\r\n                    pictureinpicture: tab.pictureinpicture,\r\n                    notselectedsinceload: tab.getAttribute(\"notselectedsinceload\"),\r\n                });\r\n                // we need to use classes for the usercontext/container, since the built-in CSS that sets the identity color & icon uses classes, not attributes.\r\n                if (tab.userContextId) {\r\n                    let idColor = ContextualIdentityService.getPublicIdentityFromId(\r\n                        tab.userContextId\r\n                    ) ? .color;\r\n                    row.className = idColor ?\r\n                        `all-tabs-item identity-color-${idColor}` :\r\n                        \"all-tabs-item\";\r\n                    row.setAttribute(\"usercontextid\", tab.userContextId);\r\n                } else {\r\n                    row.className = \"all-tabs-item\";\r\n                    row.removeAttribute(\"usercontextid\");\r\n                }\r\n\r\n                // set attributes on the main button, in particular the tab title and favicon.\r\n                let busy = tab.getAttribute(\"busy\");\r\n                setAttributes(row.mainButton, {\r\n                    busy,\r\n                    label: tab.label,\r\n                    image: !busy && tab.getAttribute(\"image\"),\r\n                    iconloadingprincipal: tab.getAttribute(\"iconloadingprincipal\"),\r\n                });\r\n\r\n                this._setImageAttributes(row, tab);\r\n\r\n                // decide which icon to display for the audio button, or whether it should be displayed at all.\r\n                setAttributes(row.audioButton, {\r\n                    muted: tab.muted,\r\n                    soundplaying: tab.soundPlaying,\r\n                    \"activemedia-blocked\": tab.activeMediaBlocked,\r\n                    pictureinpicture: tab.pictureinpicture,\r\n                    hidden: !(\r\n                        tab.muted ||\r\n                        tab.soundPlaying ||\r\n                        tab.activeMediaBlocked ||\r\n                        tab.pictureinpicture\r\n                    ),\r\n                });\r\n            }\r\n            /**\r\n             * show a throbber in place of the favicon while a tab is loading.\r\n             * @param {object} row (a row element)\r\n             * @param {object} tab (a row element)\r\n             */\r\n        _setImageAttributes(row, tab) {\r\n            let image = row.mainButton.icon;\r\n            if (image) {\r\n                let busy = tab.getAttribute(\"busy\");\r\n                let progress = tab.getAttribute(\"progress\");\r\n                setAttributes(image, { busy, progress });\r\n                if (busy) image.classList.add(\"tab-throbber-tabslist\");\r\n                else image.classList.remove(\"tab-throbber-tabslist\");\r\n            }\r\n        }\r\n        get mouseTargetRect() {\r\n                return windowUtils.getBoundsWithoutFlushing(this.pane);\r\n            }\r\n            /**\r\n             * get the previous or next node for a given TreeWalker\r\n             * @param {object} walker (a TreeWalker object)\r\n             * @param {boolean} prev (whether to walk backwards or forwards)\r\n             * @returns the next eligible DOM node to focus\r\n             */\r\n        getNewFocus(walker, prev) {\r\n                return prev ? walker.previousNode() : walker.nextNode();\r\n            }\r\n            /**\r\n             * cycle focus between buttons in the pane\r\n             * @param {boolean} prev (whether to go backwards or forwards)\r\n             * @param {boolean} horizontal (whether we're navigating with left/right or up/down)\r\n             */\r\n        navigateButtons(prev, horizontal) {\r\n                let walker = horizontal ? this.horizontalWalker : this.verticalWalker;\r\n                let oldFocus = document.activeElement;\r\n                walker.currentNode = oldFocus;\r\n                let newFocus = this.getNewFocus(walker, prev);\r\n                while (newFocus && newFocus.tagName == \"toolbartabstop\")\r\n                    newFocus = this.getNewFocus(walker, prev);\r\n                if (newFocus) this._focusButton(newFocus);\r\n            }\r\n            /**\r\n             * make a DOM node focusable, focus it, and add a blur listener to it that'll revert its focusability when we're done focusing it.\r\n             * we have to do it this way since we don't want ALL the buttons to be focusable with tabs.\r\n             * it looks like you can focus them with tabs, but really you're just focusing the tab stops,\r\n             * which are set up to instantly focus the next/previous element. this way you only need to tab twice to get past the pane.\r\n             * if every button was tabbable then you'd have to press the tab key at least twice for every tab you have just to get to the browser content, perhaps hundreds of times.\r\n             * instead, tab only focuses the top buttons row and the lower tabs scrollbox. once one of those is focused, arrow keys cycle between buttons.\r\n             * @param {object} button (DOM node)\r\n             */\r\n        _focusButton(button) {\r\n                button.setAttribute(\"tabindex\", \"-1\");\r\n                button.focus();\r\n                button.addEventListener(\"blur\", this);\r\n            }\r\n            // event callback when something is focused. prevent the pane from being collapsed while it's focused.\r\n            // also execute the tab stop behavior if a tab stop was focused.\r\n        _onFocus(e) {\r\n                clearTimeout(this.hoverOutTimer);\r\n                clearTimeout(this.hoverTimer);\r\n                this.hoverOutQueued = false;\r\n                this.hoverQueued = false;\r\n                if (this.pane.getAttribute(\"unpinned\") && !this.noExpand)\r\n                    this.pane.setAttribute(\"expanded\", true);\r\n                if (e.target.tagName === \"toolbartabstop\") this._onTabStopFocus(e);\r\n            }\r\n            // invoked on a blur event. if the pane is no longer focused or hovered, and it's unpinned, prepare to collapse it.\r\n        _onPaneBlur(e) {\r\n                if (this.pane.matches(\":hover, :focus-within\")) return;\r\n                clearTimeout(this.hoverOutTimer);\r\n                clearTimeout(this.hoverTimer);\r\n                this.hoverOutQueued = false;\r\n                this.hoverQueued = false;\r\n                if (this.noExpand) return this.pane.removeAttribute(\"expanded\"); // if the pane is set to not expand, forget about all this.\r\n                // if the pane was blurred because a context menu was opened, defer this behavior until the context menu is hidden.\r\n                let openMenu = this.openMenu;\r\n                if (openMenu) {\r\n                    openMenu.addEventListener(\"popuphidden\", (e) => this._onPaneBlur(e), {\r\n                        once: true,\r\n                    });\r\n                    return;\r\n                }\r\n                this.pane.removeAttribute(\"expanded\");\r\n            }\r\n            // if a button was blurred, make it un-tabbable again.\r\n        _onButtonBlur(e) {\r\n                if (document.activeElement == e.target) return;\r\n                e.target.removeEventListener(\"blur\", this);\r\n                e.target.removeAttribute(\"tabindex\");\r\n            }\r\n            // this one is pretty complicated. if a tab stop was focused, we need to pass focus to the next eligible element.\r\n            // the only truly focusable elements in the pane are tab stops. but the first button after a tab stop receives focus from the tab stop.\r\n            // then the buttons that come after it can be focused with arrow keys. but we also need to check if user is tabbing *out* of the pane,\r\n            // and pass focus to the next eligible button outside of the pane (probably a button)\r\n            // see browser-toolbarKeyNav.js for more details on this concept.\r\n        _onTabStopFocus(e) {\r\n                let walker = this.horizontalWalker;\r\n                let oldFocus = e.relatedTarget;\r\n                let isButton = (node) => node.tagName == \"button\" || node.tagName == \"toolbarbutton\";\r\n                if (oldFocus) {\r\n                    this._isFocusMovingBackward =\r\n                        oldFocus.compareDocumentPosition(e.target) & Node.DOCUMENT_POSITION_PRECEDING;\r\n                    if (this._isFocusMovingBackward && oldFocus && isButton(oldFocus)) {\r\n                        document.commandDispatcher.rewindFocus();\r\n                        return;\r\n                    }\r\n                }\r\n                walker.currentNode = e.target;\r\n                let button = walker.nextNode();\r\n                if (!button || !isButton(button)) {\r\n                    if (\r\n                        oldFocus &&\r\n                        this._isFocusMovingBackward &&\r\n                        !gNavToolbox.contains(oldFocus) &&\r\n                        !this.pane.contains(oldFocus)\r\n                    ) {\r\n                        let allStops = [...document.querySelectorAll(\"toolbartabstop\")];\r\n                        let earlierVisibleStopIndex = allStops.indexOf(e.target) - 1;\r\n                        while (earlierVisibleStopIndex >= 0) {\r\n                            let stop = allStops[earlierVisibleStopIndex];\r\n                            let stopContainer = this.pane.contains(stop) ?\r\n                                this.pane :\r\n                                stop.closest(\"toolbar\");\r\n                            if (window.windowUtils.getBoundsWithoutFlushing(stopContainer).height > 0)\r\n                                break;\r\n                            earlierVisibleStopIndex--;\r\n                        }\r\n                        if (earlierVisibleStopIndex == -1) this._isFocusMovingBackward = false;\r\n                    }\r\n                    if (this._isFocusMovingBackward) document.commandDispatcher.rewindFocus();\r\n                    else document.commandDispatcher.advanceFocus();\r\n                    return;\r\n                }\r\n                this._focusButton(button);\r\n            }\r\n            // when a key is pressed, navigate the focus (or remove it for esc key)\r\n        _onKeyDown(e) {\r\n                let accelKey = AppConstants.platform == \"macosx\" ? e.metaKey : e.ctrlKey;\r\n                if (e.altKey || e.shiftKey || accelKey) return;\r\n                switch (e.key) {\r\n                    case \"ArrowLeft\":\r\n                        this.navigateButtons(!window.RTL_UI, !this.noExpand);\r\n                        break;\r\n                    case \"ArrowRight\":\r\n                        // Previous if UI is RTL, next if UI is LTR.\r\n                        this.navigateButtons(window.RTL_UI, !this.noExpand);\r\n                        break;\r\n                    case \"ArrowUp\":\r\n                        this.navigateButtons(true);\r\n                        break;\r\n                    case \"ArrowDown\":\r\n                        this.navigateButtons(false);\r\n                        break;\r\n                    case \"Escape\":\r\n                        if (this.pane.contains(document.activeElement)) {\r\n                            document.activeElement.blur();\r\n                            break;\r\n                        }\r\n                        // fall through\r\n                    default:\r\n                        return;\r\n                }\r\n                e.preventDefault();\r\n            }\r\n            // when you left-click a tab, the first thing that happens is selection. this happens on mouse down, not on mouse up.\r\n            // if holding shift key or ctrl key, perform multiselection operations. otherwise, just select the clicked tab.\r\n        _onMouseDown(e, tab) {\r\n                if (e.button !== 0) return;\r\n                let accelKey = AppConstants.platform == \"macosx\" ? e.metaKey : e.ctrlKey;\r\n                if (e.shiftKey) {\r\n                    const lastSelectedTab = gBrowser.lastMultiSelectedTab;\r\n                    if (!accelKey) {\r\n                        gBrowser.selectedTab = lastSelectedTab;\r\n                        gBrowser.clearMultiSelectedTabs();\r\n                    }\r\n                    gBrowser.addRangeToMultiSelectedTabs(lastSelectedTab, tab);\r\n                    e.preventDefault();\r\n                } else if (accelKey) {\r\n                    if (tab.multiselected) gBrowser.removeFromMultiSelectedTabs(tab);\r\n                    else if (tab != gBrowser.selectedTab) {\r\n                        gBrowser.addToMultiSelectedTabs(tab);\r\n                        gBrowser.lastMultiSelectedTab = tab;\r\n                    }\r\n                    e.preventDefault();\r\n                } else {\r\n                    if (!tab.selected && tab.multiselected) gBrowser.lockClearMultiSelectionOnce();\r\n                    if (!e.shiftKey &&\r\n                        !accelKey &&\r\n                        !e.target.classList.contains(\"all-tabs-secondary-button\") &&\r\n                        tab !== gBrowser.selectedTab\r\n                    ) {\r\n                        if (tab.getAttribute(\"pending\") || tab.getAttribute(\"busy\"))\r\n                            tab.noCanvas = true;\r\n                        else delete tab.noCanvas;\r\n                        if (gBrowser.selectedTab != tab) gBrowser.selectedTab = tab;\r\n                        else gBrowser.tabContainer._handleTabSelect();\r\n                    }\r\n                }\r\n            }\r\n            // when the mouse is released, clear the multiselection and perform some drag/drop cleanup.\r\n            // if middle mouse button was clicked, then close the tab, but first warm up the next tab that will be selected.\r\n        _onMouseUp(e, tab) {\r\n                if (e.button === 2) return;\r\n                if (e.button === 1) {\r\n                    gBrowser.warmupTab(gBrowser._findTabToBlurTo(tab));\r\n                    gBrowser.removeTab(tab, {\r\n                        animate: true,\r\n                        byMouse: false,\r\n                    });\r\n                    return;\r\n                }\r\n                let accelKey = AppConstants.platform == \"macosx\" ? e.metaKey : e.ctrlKey;\r\n                if (e.shiftKey || accelKey || e.target.classList.contains(\"all-tabs-secondary-button\"))\r\n                    return;\r\n                delete tab.noCanvas;\r\n                gBrowser.unlockClearMultiSelection();\r\n                gBrowser.clearMultiSelectedTabs();\r\n            }\r\n            // when mouse enters the pane, prepare to expand the pane after the specified delay.\r\n        _onMouseEnter(e) {\r\n                clearTimeout(this.hoverOutTimer);\r\n                this.hoverOutQueued = false;\r\n                if (!this.pane.getAttribute(\"unpinned\") || this.noExpand)\r\n                    return this.pane.removeAttribute(\"expanded\");\r\n                if (this.hoverQueued) return;\r\n                this.hoverQueued = true;\r\n                this.hoverTimer = setTimeout(() => {\r\n                    this.hoverQueued = false;\r\n                    this.pane.setAttribute(\"expanded\", true);\r\n                }, this.hoverDelay);\r\n            }\r\n            // when mouse leaves the pane, prepare to collapse the pane...\r\n        _onMouseLeave(e, delay) {\r\n            clearTimeout(this.hoverTimer);\r\n            this.hoverQueued = false;\r\n            if (this.hoverOutQueued) return;\r\n            this.hoverOutQueued = true;\r\n            this.hoverOutTimer = setTimeout(() => {\r\n                this.hoverOutQueued = false;\r\n                if (this.pane.matches(\":hover, :focus-within\")) return;\r\n                if (e.type === \"popuphidden\" && Services.focus.activeWindow === window) {\r\n                    let rect = this.mouseTargetRect;\r\n                    let { _x, _y } = MousePosTracker;\r\n                    if (_x >= rect.left && _x <= rect.right && _y >= rect.top && _y <= rect.bottom)\r\n                        return;\r\n                }\r\n                if (this.noExpand) return this.pane.removeAttribute(\"expanded\");\r\n                // again, don't collapse the pane yet if the mouse left because a context menu was opened on the pane.\r\n                // wait until the context menu is closed before collapsing the pane.\r\n                let openMenu = this.openMenu;\r\n                if (openMenu) {\r\n                    openMenu.addEventListener(\"popuphidden\", (e) => this._onMouseLeave(e, 0), {\r\n                        once: true,\r\n                    });\r\n                    return;\r\n                }\r\n                this.pane.removeAttribute(\"expanded\");\r\n            }, delay ? ? this.hoverOutDelay);\r\n        }\r\n        _onDeactivate(e) {\r\n            clearTimeout(this.hoverTimer);\r\n            clearTimeout(this.hoverOutTimer);\r\n            this.hoverQueued = false;\r\n            this.hoverOutQueued = false;\r\n            this.pane.removeAttribute(\"expanded\");\r\n        }\r\n        unpin() {\r\n                this.pane.style.setProperty(\"--pane-width\", this.pane.width + \"px\");\r\n                this.pane.style.setProperty(\r\n                    \"--pane-transition-duration\",\r\n                    (Math.sqrt(this.pane.width / 350) * 0.25).toFixed(2) + \"s\"\r\n                );\r\n                if (this.pane.matches(\":hover, :focus-within\") && !this.noExpand)\r\n                    this.pane.setAttribute(\"expanded\", true);\r\n                this.pane.setAttribute(\"unpinned\", true);\r\n            }\r\n            // \"click\" events work kind of like \"mouseup\" events, but in this case we're only using this to prevent the click event yielding a command event.\r\n        _onClick(e) {\r\n                if (e.button !== 0 || e.target.classList.contains(\"all-tabs-secondary-button\")) return;\r\n                e.preventDefault();\r\n            }\r\n            // \"command\" events happen on click or on spacebar/enter. we want the buttons to be keyboard accessible too.\r\n            // so this is how the mute button and close button work, and ultimately how you select a tab with the keyboard.\r\n        _onCommand(e, tab) {\r\n                if (e.target.hasAttribute(\"toggle-mute\")) {\r\n                    tab.multiselected ?\r\n                        gBrowser.toggleMuteAudioOnMultiSelectedTabs(tab) :\r\n                        tab.toggleMuteAudio();\r\n                    return;\r\n                }\r\n                if (e.target.hasAttribute(\"close-button\")) {\r\n                    if (tab.multiselected) gBrowser.removeMultiSelectedTabs();\r\n                    else gBrowser.removeTab(tab, { animate: true });\r\n                    return;\r\n                }\r\n                if (!gSharedTabWarning.willShowSharedTabWarning(tab))\r\n                    if (tab !== gBrowser.selectedTab) this._selectTab(tab);\r\n                delete tab.noCanvas;\r\n            }\r\n            // invoked on \"dragstart\" event. first figure out what we're dragging and set a drag image.\r\n        _onDragStart(e, tab) {\r\n                let row = e.target;\r\n                if (!tab || gBrowser.tabContainer._isCustomizing) return;\r\n                let selectedTabs = gBrowser.selectedTabs;\r\n                let otherSelectedTabs = selectedTabs.filter((selectedTab) => selectedTab != tab);\r\n                let dataTransferOrderedTabs = [tab].concat(otherSelectedTabs);\r\n                let dt = e.dataTransfer;\r\n                for (let i = 0; i < dataTransferOrderedTabs.length; i++) {\r\n                    let dtTab = dataTransferOrderedTabs[i];\r\n                    dt.mozSetDataAt(\"all-tabs-item\", dtTab, i);\r\n                }\r\n                dt.mozCursor = \"default\";\r\n                dt.addElement(row);\r\n                // if multiselected tabs aren't adjacent, make them adjacent\r\n                if (tab.multiselected) {\r\n                    let newIndex = (aTab, index) => {\r\n                        if (aTab.pinned) return Math.min(index, gBrowser._numPinnedTabs - 1);\r\n                        return Math.max(index, gBrowser._numPinnedTabs);\r\n                    };\r\n                    let tabIndex = selectedTabs.indexOf(tab);\r\n                    let draggedTabPos = tab._tPos;\r\n                    // tabs to the left of the dragged tab\r\n                    let insertAtPos = draggedTabPos - 1;\r\n                    for (let i = tabIndex - 1; i > -1; i--) {\r\n                        insertAtPos = newIndex(selectedTabs[i], insertAtPos);\r\n                        if (insertAtPos && !selectedTabs[i].nextElementSibling.multiselected)\r\n                            gBrowser.moveTabTo(selectedTabs[i], insertAtPos);\r\n                    }\r\n                    // tabs to the right\r\n                    insertAtPos = draggedTabPos + 1;\r\n                    for (let i = tabIndex + 1; i < selectedTabs.length; i++) {\r\n                        insertAtPos = newIndex(selectedTabs[i], insertAtPos);\r\n                        if (insertAtPos && !selectedTabs[i].previousElementSibling.multiselected)\r\n                            gBrowser.moveTabTo(selectedTabs[i], insertAtPos);\r\n                    }\r\n                }\r\n                // tab preview\r\n                if (!tab.noCanvas &&\r\n                    (AppConstants.platform == \"win\" || AppConstants.platform == \"macosx\")\r\n                ) {\r\n                    delete tab.noCanvas;\r\n                    let windowUtils = window.windowUtils;\r\n                    let scale = windowUtils.screenPixelsPerCSSPixel / windowUtils.fullZoom;\r\n                    let canvas = this._dndCanvas;\r\n                    if (!canvas) {\r\n                        this._dndCanvas = canvas = document.createElementNS(\r\n                            \"http://www.w3.org/1999/xhtml\",\r\n                            \"canvas\"\r\n                        );\r\n                        canvas.style.width = \"100%\";\r\n                        canvas.style.height = \"100%\";\r\n                        canvas.mozOpaque = true;\r\n                    }\r\n                    canvas.width = 160 * scale;\r\n                    canvas.height = 90 * scale;\r\n                    let toDrag = canvas;\r\n                    let dragImageOffset = -16;\r\n                    let browser = tab.linkedBrowser;\r\n                    if (gMultiProcessBrowser) {\r\n                        let context = canvas.getContext(\"2d\");\r\n                        context.fillStyle = getComputedStyle(this.pane).getPropertyValue(\r\n                            \"background-color\"\r\n                        );\r\n                        context.fillRect(0, 0, canvas.width, canvas.height);\r\n\r\n                        let captureListener = () =>\r\n                            dt.updateDragImage(canvas, dragImageOffset, dragImageOffset);\r\n                        PageThumbs.captureToCanvas(browser, canvas).then(captureListener);\r\n                    } else {\r\n                        PageThumbs.captureToCanvas(browser, canvas);\r\n                        dragImageOffset = dragImageOffset * scale;\r\n                    }\r\n                    dt.setDragImage(toDrag, dragImageOffset, dragImageOffset);\r\n                }\r\n                tab._dragData = {\r\n                    movingTabs: (tab.multiselected ? gBrowser.selectedTabs : [tab]).filter(\r\n                        this.filterFn\r\n                    ),\r\n                };\r\n                e.stopPropagation();\r\n            }\r\n            // invoked when we drag over an element inside the pane.\r\n            // decide whether to show the drag-over styling on a row, and whether to show the drag indicator above or below the row.\r\n        _onDragOver(e) {\r\n                let row = this.findRow(e.target);\r\n                let dt = e.dataTransfer;\r\n                // scroll when dragging near the ends of the scrollbox\r\n                let pixelsToScroll = 0;\r\n                let rect = this.containerNode.getBoundingClientRect();\r\n                if (row) {\r\n                    let targetRect = row.getBoundingClientRect();\r\n                    let increment = (targetRect.height || this.containerNode.scrollIncrement) * 3;\r\n                    if (e.clientY - rect.top < targetRect.height) pixelsToScroll = increment * -1;\r\n                    else if (rect.bottom - e.clientY < targetRect.height) pixelsToScroll = increment;\r\n                    if (pixelsToScroll) this.containerNode.scrollByPixels(pixelsToScroll, false);\r\n                }\r\n                this.containerNode\r\n                    .querySelectorAll(\"[dragpos]\")\r\n                    .forEach((item) => item.removeAttribute(\"dragpos\"));\r\n                if (!dt.types.includes(\"all-tabs-item\") || !row || row.tab.multiselected) {\r\n                    dt.mozCursor = \"auto\";\r\n                    return;\r\n                }\r\n                dt.mozCursor = \"default\";\r\n                let draggedTab = dt.mozGetDataAt(\"all-tabs-item\", 0);\r\n                if (row.tab === draggedTab) return;\r\n                if (row.tab.pinned !== draggedTab.pinned) return;\r\n                // whether a tab will be placed before or after the drop target depends on 1) whether the drop target is above or below the dragged tab, and 2) whether the order of the tab list is reversed.\r\n                let getPosition = () => {\r\n                    return this.reversed ?\r\n                        row.tab._tPos < draggedTab._tPos :\r\n                        row.tab._tPos > draggedTab._tPos;\r\n                };\r\n                let position = getPosition() ? \"after\" : \"before\";\r\n                row.setAttribute(\"dragpos\", position);\r\n                e.preventDefault();\r\n            }\r\n            // invoked when we drag over an element then leave it. clean up the dragpos attribute.\r\n            // we actually do this for every row (wasteful, I know) since these events are dispatched too slowly. I guess it's a firefox bug, idk.\r\n        _onDragLeave(e) {\r\n                let row = this.findRow(e.target);\r\n                let dt = e.dataTransfer;\r\n                dt.mozCursor = \"auto\";\r\n                if (!dt.types.includes(\"all-tabs-item\") || !row) return;\r\n                this.containerNode\r\n                    .querySelectorAll(\"[dragpos]\")\r\n                    .forEach((item) => item.removeAttribute(\"dragpos\"));\r\n            }\r\n            // invoked when we finally release the dragged tab(s). figure out where to move the tab to, move it, do some cleanup.\r\n        _onDrop(e) {\r\n                let row = this.findRow(e.target);\r\n                let dt = e.dataTransfer;\r\n                let tabBar = gBrowser.tabContainer;\r\n\r\n                if (!dt.types.includes(\"all-tabs-item\") || !row) return;\r\n\r\n                let draggedTab = dt.mozGetDataAt(\"all-tabs-item\", 0);\r\n                let movingTabs = draggedTab._dragData.movingTabs;\r\n\r\n                if (!movingTabs ||\r\n                    dt.mozUserCancelled ||\r\n                    dt.dropEffect === \"none\" ||\r\n                    tabBar._isCustomizing\r\n                ) {\r\n                    delete draggedTab._dragData;\r\n                    return;\r\n                }\r\n\r\n                tabBar._finishGroupSelectedTabs(draggedTab);\r\n\r\n                if (draggedTab) {\r\n                    let newIndex = row.tab._tPos;\r\n                    const dir = newIndex < movingTabs[0]._tPos;\r\n                    movingTabs.forEach((tab) => {\r\n                        if (tab.pinned !== row.tab.pinned) return;\r\n                        gBrowser.moveTabTo(\r\n                            dt.dropEffect == \"copy\" ? gBrowser.duplicateTab(tab) : tab,\r\n                            dir ? newIndex++ : newIndex\r\n                        );\r\n                    });\r\n                }\r\n                row.removeAttribute(\"dragpos\");\r\n                e.stopPropagation();\r\n            }\r\n            // invoked when dragging ends, whether by dropping or by exiting. just cleans up after the other drag event handlers.\r\n        _onDragEnd(e) {\r\n                let draggedTab = e.dataTransfer.mozGetDataAt(\"all-tabs-item\", 0);\r\n                delete draggedTab._dragData;\r\n                delete draggedTab.noCanvas;\r\n                for (let row of this.rows) row.removeAttribute(\"dragpos\");\r\n            }\r\n            // callback function for the TabMultiSelect custom event. this event doesn't get dispatched to a specific tab,\r\n            // because multiple tabs can be multiselected by the same operation. so we can't use its target to specify which row's attributes to change.\r\n            // we therefore have to update the \"multiselected\" attribute for every row.\r\n        _onTabMultiSelect() {\r\n                for (let item of this.rows)\r\n                    !!item.tab.multiselected ?\r\n                    item.setAttribute(\"multiselected\", true) :\r\n                    item.removeAttribute(\"multiselected\");\r\n            }\r\n            // invoked when mousing over a row. we want to speculatively warm up a tab when the user hovers it since it's possible they will click it.\r\n            // there's a cache for this with a maximum limit, so if the user mouses over 3 tabs without clicking them, then a 4th, it will clear the 1st to make room.\r\n            // this is the same thing the built-in tab bar does so we're just mimicking vanilla behavior here. this can be disabled with browser.tabs.remote.warmup.enabled\r\n        warmupRowTab(e, tab) {\r\n                let row = this.findRow(e.target);\r\n                SessionStore.speculativeConnectOnTabHover(tab);\r\n                if (row.closeButton.matches(\":hover\")) tab = gBrowser._findTabToBlurTo(tab);\r\n                gBrowser.warmupTab(tab);\r\n            }\r\n            // generate tooltip labels and decide where to anchor the tooltip. invoked when the vertical-tabs-tooltip is about to be shown.\r\n        createTabTooltip(e) {\r\n                e.stopPropagation();\r\n                let row = e.target.triggerNode ? this.findRow(e.target.triggerNode) : null;\r\n                if (!row) return e.preventDefault();\r\n                let { tab } = row;\r\n                if (!tab) return e.preventDefault();\r\n                // get a localized string, replace any plural variables with the passed number, and add a shortcut string (e.g. Ctrl+M) matching the passed key element ID.\r\n                let stringWithShortcut = (stringId, keyElemId, pluralCount) => {\r\n                    let keyElem = document.getElementById(keyElemId);\r\n                    let shortcut = ShortcutUtils.prettifyShortcut(keyElem);\r\n                    return PluralForm.get(pluralCount, gTabBrowserBundle.GetStringFromName(stringId))\r\n                        .replace(\"%S\", shortcut)\r\n                        .replace(\"#1\", pluralCount);\r\n                };\r\n                let label;\r\n                let align = true; // should we align to the tab or to the mouse? depends on which element was hovered.\r\n                let { linkedBrowser } = tab;\r\n                const selectedTabs = gBrowser.selectedTabs;\r\n                const contextTabInSelection = selectedTabs.includes(tab);\r\n                const affectedTabsLength = contextTabInSelection ? selectedTabs.length : 1;\r\n                // a bunch of localization\r\n                if (row.closeButton.matches(\":hover\")) {\r\n                    let shortcut = ShortcutUtils.prettifyShortcut(key_close);\r\n                    label = PluralForm.get(\r\n                        affectedTabsLength,\r\n                        gTabBrowserBundle.GetStringFromName(\"tabs.closeTabs.tooltip\")\r\n                    ).replace(\"#1\", affectedTabsLength);\r\n                    if (contextTabInSelection && shortcut) {\r\n                        if (label.includes(\"%S\")) label = label.replace(\"%S\", shortcut);\r\n                        else label = label + \" (\" + shortcut + \")\";\r\n                    }\r\n                    align = false;\r\n                } else if (row.audioButton.matches(\":hover\")) {\r\n                    let stringID;\r\n                    if (contextTabInSelection) {\r\n                        stringID = linkedBrowser.audioMuted ?\r\n                            \"tabs.unmuteAudio2.tooltip\" :\r\n                            \"tabs.muteAudio2.tooltip\";\r\n                        label = stringWithShortcut(stringID, \"key_toggleMute\", affectedTabsLength);\r\n                    } else {\r\n                        if (tab.hasAttribute(\"activemedia-blocked\"))\r\n                            stringID = \"tabs.unblockAudio2.tooltip\";\r\n                        else\r\n                            stringID = linkedBrowser.audioMuted ?\r\n                            \"tabs.unmuteAudio2.background.tooltip\" :\r\n                            \"tabs.muteAudio2.background.tooltip\";\r\n                        label = PluralForm.get(\r\n                            affectedTabsLength,\r\n                            gTabBrowserBundle.GetStringFromName(stringID)\r\n                        ).replace(\"#1\", affectedTabsLength);\r\n                    }\r\n                    align = false;\r\n                } else {\r\n                    label = tab._fullLabel || tab.getAttribute(\"label\");\r\n                    // show the tab's process ID in the tooltip?\r\n                    if (prefSvc.getBoolPref(\"browser.tabs.tooltipsShowPidAndActiveness\", false))\r\n                        if (linkedBrowser) {\r\n                            let [contentPid, ...framePids] = this.E10SUtils.getBrowserPids(\r\n                                linkedBrowser,\r\n                                gFissionBrowser\r\n                            );\r\n                            if (contentPid) {\r\n                                label += \" (pid \" + contentPid + \")\";\r\n                                if (gFissionBrowser) {\r\n                                    label += \" [F\";\r\n                                    if (framePids.length) label += \" \" + framePids.join(\", \");\r\n                                    label += \"]\";\r\n                                }\r\n                            }\r\n                            if (linkedBrowser.docShellIsActive) label += \" [A]\";\r\n                        }\r\n                        // add the container name to the tooltip?\r\n                    if (tab.userContextId)\r\n                        label = gTabBrowserBundle.formatStringFromName(\"tabs.containers.tooltip\", [\r\n                            label,\r\n                            ContextualIdentityService.getUserContextLabel(tab.userContextId),\r\n                        ]);\r\n                    // if hovering the sound overlay, show the current media state of the tab, after the tab title.\r\n                    // \"playing\" or \"muted\" or \"media blocked\"\r\n                    if (row.soundOverlay.matches(\":hover\"))\r\n                        label += ` (${this.fluentStrings[\r\n                        tab.hasAttribute(\"activemedia-blocked\")\r\n                            ? \"blockedString\"\r\n                            : linkedBrowser.audioMuted\r\n                            ? \"mutedString\"\r\n                            : \"playingString\"\r\n                    ].toLowerCase()})`;\r\n                }\r\n                // align to the row\r\n                if (align) {\r\n                    e.target.setAttribute(\"position\", \"after_start\");\r\n                    e.target.moveToAnchor(row, \"after_start\");\r\n                }\r\n                let title = e.target.querySelector(\".places-tooltip-title\");\r\n                let url = e.target.querySelector(\".places-tooltip-uri\");\r\n                let icon = e.target.querySelector(\"#places-tooltip-insecure-icon\");\r\n                title.textContent = label;\r\n                url.value = linkedBrowser ? .currentURI ? .spec.replace(/^https:\\/\\//, \"\");\r\n                // show a lock icon to show tab security/encryption\r\n                let pending = tab.hasAttribute(\"pending\") || !linkedBrowser.browsingContext;\r\n                let docURI = pending ?\r\n                    linkedBrowser ? .currentURI :\r\n                    linkedBrowser ? .documentURI || linkedBrowser ? .currentURI;\r\n                if (docURI) {\r\n                    let homePage = new RegExp(\r\n                        `(${BROWSER_NEW_TAB_URL}|${HomePage.get(window)})`,\r\n                        \"i\"\r\n                    ).test(docURI.spec);\r\n                    if (homePage) {\r\n                        icon.setAttribute(\"type\", \"home-page\");\r\n                        icon.hidden = false;\r\n                        return;\r\n                    }\r\n                    switch (docURI.scheme) {\r\n                        case \"file\":\r\n                        case \"resource\":\r\n                        case \"chrome\":\r\n                            icon.setAttribute(\"type\", \"local-page\");\r\n                            icon.hidden = false;\r\n                            return;\r\n                        case \"about\":\r\n                            let pathQueryRef = docURI ? .pathQueryRef;\r\n                            if (\r\n                                pathQueryRef &&\r\n                                /^(neterror|certerror|httpsonlyerror)/.test(pathQueryRef)\r\n                            ) {\r\n                                icon.setAttribute(\"type\", \"error-page\");\r\n                                icon.hidden = false;\r\n                                return;\r\n                            }\r\n                            if (docURI.filePath == \"blocked\") {\r\n                                icon.setAttribute(\"type\", \"blocked-page\");\r\n                                icon.hidden = false;\r\n                                return;\r\n                            }\r\n                            icon.setAttribute(\"type\", \"about-page\");\r\n                            icon.hidden = false;\r\n                            return;\r\n                        case \"moz-extension\":\r\n                            icon.setAttribute(\"type\", \"extension-page\");\r\n                            icon.hidden = false;\r\n                            return;\r\n                    }\r\n                }\r\n                if (linkedBrowser.browsingContext) {\r\n                    let prog = Ci.nsIWebProgressListener;\r\n                    let state = linkedBrowser ? .securityUI ? .state;\r\n                    if (typeof state != \"number\" || state & prog.STATE_IS_SECURE) {\r\n                        icon.hidden = true;\r\n                        icon.setAttribute(\"type\", \"secure\");\r\n                        return;\r\n                    }\r\n                    if (state & prog.STATE_IS_INSECURE) {\r\n                        icon.setAttribute(\"type\", \"insecure\");\r\n                        icon.hidden = false;\r\n                        return;\r\n                    }\r\n                    if (state & prog.STATE_IS_BROKEN) {\r\n                        if (state & prog.STATE_LOADED_MIXED_ACTIVE_CONTENT) {\r\n                            icon.hidden = false;\r\n                            icon.setAttribute(\"type\", \"insecure\");\r\n                        } else {\r\n                            icon.setAttribute(\"type\", \"mixed-passive\");\r\n                            icon.hidden = false;\r\n                        }\r\n                        return;\r\n                    }\r\n                }\r\n                icon.hidden = true;\r\n                icon.setAttribute(\"type\", pending ? \"pending\" : \"secure\");\r\n            }\r\n            // container tab settings affect what we need to show in the \"New Tab\" button's tooltip and context menu.\r\n            // so we need to observe this preference and respond accordingly.\r\n        handlePrivacyChange() {\r\n                let containersEnabled =\r\n                    prefSvc.getBoolPref(userContextPref) &&\r\n                    !PrivateBrowsingUtils.isWindowPrivate(window);\r\n                const newTabLeftClickOpensContainersMenu = prefSvc.getBoolPref(containerOnClickPref);\r\n                let parent = this.newTabButton;\r\n                parent.removeAttribute(\"type\");\r\n                if (parent.menupopup) parent.menupopup.remove();\r\n                if (containersEnabled) {\r\n                    parent.setAttribute(\"context\", \"new-tab-button-popup\");\r\n                    let popup = document.getElementById(\"new-tab-button-popup\").cloneNode(true);\r\n                    popup.removeAttribute(\"id\");\r\n                    popup.className = \"new-tab-popup\";\r\n                    popup.setAttribute(\"position\", \"after_end\");\r\n                    parent.prepend(popup);\r\n                    parent.setAttribute(\"type\", \"menu\");\r\n                    nodeToTooltipMap[parent.id] = newTabLeftClickOpensContainersMenu ?\r\n                        \"newTabAlwaysContainer.tooltip\" :\r\n                        \"newTabContainer.tooltip\";\r\n                } else {\r\n                    nodeToTooltipMap[parent.id] = \"newTabButton.tooltip\";\r\n                    parent.removeAttribute(\"context\", \"new-tab-button-popup\");\r\n                }\r\n                gDynamicTooltipCache.delete(parent.id);\r\n                if (containersEnabled && !newTabLeftClickOpensContainersMenu) {\r\n                    gClickAndHoldListenersOnElement.add(parent);\r\n                } else {\r\n                    gClickAndHoldListenersOnElement.remove(parent);\r\n                }\r\n            }\r\n            // load our stylesheet as an author sheet. override it with userChrome.css and !important rules.\r\n        registerSheet() {\r\n                let css = /* css */ `\r\n#vertical-tabs-pane {\r\n    --vertical-tabs-padding: 4px;\r\n    --collapsed-pane-width: calc(\r\n        16px + var(--vertical-tabs-padding) * 2 + var(--arrowpanel-menuitem-padding-inline) * 2\r\n    );\r\n    background-color: var(--vertical-tabs-pane-background, var(--lwt-accent-color));\r\n    padding: var(--vertical-tabs-padding);\r\n    border-color: var(--sidebar-border-color);\r\n    border-block-style: none;\r\n    border-inline-style: solid;\r\n    border-inline-width: 1px 0;\r\n    z-index: 2;\r\n}\r\n#vertical-tabs-pane[positionstart] {\r\n    border-inline-width: 0 1px;\r\n}\r\n#vertical-tabs-pane:not([unpinned]) {\r\n    min-width: 160px;\r\n    max-width: 50vw;\r\n}\r\n#vertical-tabs-pane:not([hidden]) {\r\n    min-height: 0;\r\n    display: flex;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([hidden]) {\r\n    position: relative;\r\n    z-index: 1;\r\n    margin-inline: 0;\r\n    max-width: var(--collapsed-pane-width);\r\n    min-width: var(--collapsed-pane-width);\r\n    width: var(--collapsed-pane-width);\r\n    height: 0;\r\n    transition-property: min-width, max-width, margin;\r\n    transition-timing-function: ease-in-out, ease-in-out, ease-in-out;\r\n    transition-duration: var(--pane-transition-duration), var(--pane-transition-duration), var(--pane-transition-duration);\r\n}\r\n#vertical-tabs-pane[unpinned]:not([positionstart=\"true\"]) {\r\n    left: auto;\r\n    right: 0;\r\n    margin-inline: 0;\r\n}\r\n#vertical-tabs-pane[unpinned][expanded] {\r\n    min-width: var(--pane-width, 350px);\r\n    width: var(--pane-width, 350px);\r\n    max-width: var(--pane-width, 350px);\r\n    margin-inline: 0 calc(var(--collapsed-pane-width) - var(--pane-width, 350px));\r\n}\r\n#vertical-tabs-pane[unpinned][expanded]:not([positionstart=\"true\"]) {\r\n    margin-inline: calc(var(--collapsed-pane-width) - var(--pane-width, 350px)) 0;\r\n}\r\n#vertical-tabs-pane[no-expand] {\r\n    transition: none !important;\r\n}\r\n#vertical-tabs-splitter {\r\n    border: none;\r\n}\r\n#vertical-tabs-pane[unpinned] ~ #vertical-tabs-splitter {\r\n    display: none;\r\n}\r\n#vertical-tabs-inner-box {\r\n    overflow: hidden;\r\n    width: -moz-available;\r\n    min-width: calc(16px + var(--arrowpanel-menuitem-padding-inline) * 2);\r\n    height: min-content;\r\n    max-height: 100%;\r\n}\r\n#vertical-tabs-buttons-row {\r\n    min-width: 0 !important;\r\n}\r\n#vertical-tabs-pane[no-expand][unpinned] #vertical-tabs-buttons-row {\r\n    -moz-box-orient: vertical;\r\n}\r\n#vertical-tabs-buttons-row > toolbarbutton {\r\n    margin: 0 !important;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded]) #vertical-tabs-buttons-row > toolbarbutton {\r\n    min-width: calc(16px + var(--arrowpanel-menuitem-padding-inline) * 2) !important;\r\n}\r\n/* tabs */\r\n#vertical-tabs-list .all-tabs-item {\r\n    border-radius: var(--arrowpanel-menuitem-border-radius);\r\n    box-shadow: none;\r\n    -moz-box-align: center;\r\n    padding-inline-end: 2px;\r\n    margin: 0;\r\n    overflow-x: -moz-hidden-unscrollable;\r\n    position: relative;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded]) #vertical-tabs-list .all-tabs-item {\r\n    padding-inline-end: 0;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-button:not([disabled], [open]):focus {\r\n    background: none;\r\n}\r\n#vertical-tabs-list\r\n    .all-tabs-item:is([selected], [multiselected], [usercontextid]:is(:hover, [_moz-menuactive]))\r\n    .all-tabs-button {\r\n    background-image: linear-gradient(\r\n        to right,\r\n        var(--main-stripe-color) 0,\r\n        var(--main-stripe-color) 4px,\r\n        transparent 4px\r\n    ) !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item[selected] {\r\n    font-weight: normal;\r\n    background-color: var(--arrowpanel-dimmed-further) !important;\r\n    --main-stripe-color: var(--arrowpanel-dimmed-even-further);\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-button {\r\n    min-height: revert;\r\n}\r\n#vertical-tabs-list .all-tabs-item[usercontextid]:not([multiselected]) {\r\n    --main-stripe-color: var(--identity-tab-color);\r\n}\r\n#vertical-tabs-list .all-tabs-item[multiselected] {\r\n    --main-stripe-color: var(--multiselected-color, var(--toolbarbutton-icon-fill-attention));\r\n}\r\n#vertical-tabs-list\r\n    .all-tabs-item:not([selected]):is(:hover, :focus-within, [_moz-menuactive], [multiselected]) {\r\n    background-color: var(--arrowpanel-dimmed) !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item[multiselected]:not([selected]):is(:hover, [_moz-menuactive]) {\r\n    background-color: var(--arrowpanel-dimmed-further) !important;\r\n}\r\n#vertical-tabs-list\r\n    .all-tabs-item[pending]:not([selected]):is(:hover, :focus-within, [_moz-menuactive], [multiselected]) {\r\n    background-color: var(\r\n        --arrowpanel-faint,\r\n        color-mix(in srgb, var(--arrowpanel-dimmed) 60%, transparent)\r\n    ) !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item[pending][multiselected]:not([selected]):is(:hover, [_moz-menuactive]) {\r\n    background-color: var(--arrowpanel-dimmed) !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item[pending] > .all-tabs-button {\r\n    opacity: 0.6;\r\n}\r\n:root[italic-unread-tabs] .all-tabs-item[notselectedsinceload]:not([pending]) > .all-tabs-button,\r\n:root[italic-unread-tabs] .all-tabs-item[notselectedsinceload][pending] > .all-tabs-button[busy] {\r\n    font-style: italic;\r\n}\r\n/* secondary buttons inside a tab row */\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button {\r\n    width: 18px;\r\n    height: 18px;\r\n    border-radius: var(--tab-button-border-radius, 2px);\r\n    color: inherit;\r\n    background-color: transparent !important;\r\n    opacity: 0.7;\r\n    min-height: revert;\r\n    min-width: revert;\r\n    padding: 0;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button > .toolbarbutton-icon {\r\n    min-width: 18px;\r\n    min-height: 18px;\r\n    fill: inherit;\r\n    fill-opacity: inherit;\r\n    -moz-context-properties: inherit;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button > label:empty {\r\n    display: none;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button:is(:hover, :focus):not([disabled]),\r\n#vertical-tabs-list\r\n    .all-tabs-item:is(:hover, :focus-within)\r\n    .all-tabs-secondary-button[close-button]:is(:hover, :focus):not([disabled]) {\r\n    background-color: var(--arrowpanel-dimmed) !important;\r\n    opacity: 1;\r\n    color: inherit;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button:hover:active:not([disabled]),\r\n#vertical-tabs-list\r\n    .all-tabs-item:is(:hover, :focus-within)\r\n    .all-tabs-secondary-button[close-button]:hover:active:not([disabled]) {\r\n    background-color: var(--arrowpanel-dimmed-further) !important;\r\n}\r\n/* audio button */\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[toggle-mute] {\r\n    list-style-image: none !important;\r\n    background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18px\" height=\"18px\" viewBox=\"0 0 18 18\"><path fill-opacity=\"context-fill-opacity\" fill=\"context-fill\" d=\"M3.52,5.367c-1.332,0-2.422,1.09-2.422,2.422v2.422c0,1.332,1.09,2.422,2.422,2.422h1.516l4.102,3.633 V1.735L5.035,5.367H3.52z M12.059,9c0-0.727-0.484-1.211-1.211-1.211v2.422C11.574,10.211,12.059,9.727,12.059,9z M14.48,9 c0-1.695-1.211-3.148-2.785-3.512l-0.363,1.09C12.422,6.82,13.27,7.789,13.27,9c0,1.211-0.848,2.18-1.938,2.422l0.484,1.09 C13.27,12.148,14.48,10.695,14.48,9z M12.543,3.188l-0.484,1.09C14.238,4.883,15.691,6.82,15.691,9c0,2.18-1.453,4.117-3.512,4.601 l0.484,1.09c2.422-0.605,4.238-2.906,4.238-5.691C16.902,6.215,15.086,3.914,12.543,3.188z\"/></svg>') !important;\r\n    background-size: 14px !important;\r\n    background-repeat: no-repeat !important;\r\n    background-position: center !important;\r\n    padding: 0 !important;\r\n    margin-inline-end: 8.5px;\r\n    margin-inline-start: -27px;\r\n    transition: 0.25s cubic-bezier(0.07, 0.78, 0.21, 0.95) transform,\r\n        0.2s cubic-bezier(0.07, 0.74, 0.24, 0.95) margin, 0.075s linear opacity;\r\n    display: block !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[toggle-mute][hidden] {\r\n    transform: translateX(14px);\r\n    opacity: 0;\r\n}\r\n#vertical-tabs-list\r\n    .all-tabs-item:is(:hover, :focus-within)\r\n    .all-tabs-secondary-button[toggle-mute] {\r\n    transform: translateX(48px);\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[soundplaying] {\r\n    transform: none !important;\r\n    opacity: 0.7;\r\n    margin-inline-start: -2px;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[muted] {\r\n    list-style-image: none !important;\r\n    background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18px\" height=\"18px\" viewBox=\"0 0 18 18\"><path fill-opacity=\"context-fill-opacity\" fill=\"context-fill\" d=\"M3.52,5.367c-1.332,0-2.422,1.09-2.422,2.422v2.422c0,1.332,1.09,2.422,2.422,2.422h1.516l4.102,3.633V1.735L5.035,5.367H3.52z\"/><path fill=\"context-fill\" fill-rule=\"evenodd\" d=\"M12.155,12.066l-1.138-1.138l4.872-4.872l1.138,1.138 L12.155,12.066z\"/><path fill=\"context-fill\" fill-rule=\"evenodd\" d=\"M10.998,7.204l1.138-1.138l4.872,4.872l-1.138,1.138L10.998,7.204z\"/></svg>') !important;\r\n    transform: none !important;\r\n    opacity: 0.7;\r\n    margin-inline-start: -2px;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[activemedia-blocked] {\r\n    list-style-image: none !important;\r\n    background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 12 12\"><path fill-opacity=\"context-fill-opacity\" fill=\"context-fill\" d=\"M2.128.13A.968.968 0 0 0 .676.964v10.068a.968.968 0 0 0 1.452.838l8.712-5.034a.968.968 0 0 0 0-1.676L2.128.13z\"/></svg>') !important;\r\n    background-size: 10px !important;\r\n    background-position: 4.5px center !important;\r\n    transform: none !important;\r\n    opacity: 0.7;\r\n    margin-inline-start: -2px;\r\n}\r\n#vertical-tabs-list\r\n    > .all-tabs-item:not(:hover, :focus-within)\r\n    .all-tabs-secondary-button[pictureinpicture] {\r\n    list-style-image: none !important;\r\n    background-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" viewBox=\"0 0 625.8 512\"><path fill=\"context-fill\" fill-opacity=\"context-fill-opacity\" d=\"M568.9 0h-512C25.6 0 0 25 0 56.3v398.8C0 486.4 25.6 512 56.9 512h512c31.3 0 56.9-25.6 56.9-56.9V56.3C625.8 25 600.2 0 568.9 0zm-512 425.7V86c0-16.5 13.5-30 30-30h452c16.5 0 30 13.5 30 30v339.6c0 16.5-13.5 30-30 30h-452c-16.5.1-30-13.4-30-29.9zM482 227.6H314.4c-16.5 0-30 13.5-30 30v110.7c0 16.5 13.5 30 30 30H482c16.5 0 30-13.5 30-30V257.6c0-16.5-13.5-30-30-30z\"/></svg>') !important;\r\n    border-radius: 0 !important;\r\n}\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[pictureinpicture] {\r\n    transform: none !important;\r\n    opacity: 0.7;\r\n    margin-inline-start: -2px;\r\n}\r\n/* sound overlay on the favicon */\r\n#vertical-tabs-pane .sound-overlay {\r\n    display: none;\r\n}\r\n#vertical-tabs-pane\r\n    .all-tabs-item:is([muted], [soundplaying], [activemedia-blocked])\r\n    .sound-overlay {\r\n    display: block;\r\n    position: absolute;\r\n    left: calc(var(--arrowpanel-menuitem-padding-inline) + 8px);\r\n    top: calc(var(--arrowpanel-menuitem-padding-block) + 8px);\r\n    width: 14px;\r\n    height: 14px;\r\n    -moz-context-properties: fill, fill-opacity;\r\n    fill: currentColor;\r\n    fill-opacity: 0.7;\r\n    opacity: 0;\r\n    pointer-events: none;\r\n    transition-property: opacity;\r\n    transition-timing-function: ease-in-out;\r\n    transition-duration: var(--pane-transition-duration);\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded])\r\n    .all-tabs-item:is([muted], [soundplaying], [activemedia-blocked])\r\n    .sound-overlay {\r\n    opacity: 1;\r\n    pointer-events: auto;\r\n}\r\n#vertical-tabs-pane[unpinned] .all-tabs-item[selected] .sound-overlay {\r\n    fill-opacity: inherit;\r\n}\r\n#vertical-tabs-pane[unpinned] .all-tabs-item[soundplaying] .sound-overlay {\r\n    background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18px\" height=\"18px\" viewBox=\"0 0 18 18\"><path fill-opacity=\"context-fill-opacity\" fill=\"context-fill\" d=\"M3.52,5.367c-1.332,0-2.422,1.09-2.422,2.422v2.422c0,1.332,1.09,2.422,2.422,2.422h1.516l4.102,3.633 V1.735L5.035,5.367H3.52z M12.059,9c0-0.727-0.484-1.211-1.211-1.211v2.422C11.574,10.211,12.059,9.727,12.059,9z M14.48,9 c0-1.695-1.211-3.148-2.785-3.512l-0.363,1.09C12.422,6.82,13.27,7.789,13.27,9c0,1.211-0.848,2.18-1.938,2.422l0.484,1.09 C13.27,12.148,14.48,10.695,14.48,9z M12.543,3.188l-0.484,1.09C14.238,4.883,15.691,6.82,15.691,9c0,2.18-1.453,4.117-3.512,4.601 l0.484,1.09c2.422-0.605,4.238-2.906,4.238-5.691C16.902,6.215,15.086,3.914,12.543,3.188z\"/></svg>')\r\n        center/12px no-repeat;\r\n}\r\n#vertical-tabs-pane[unpinned] .all-tabs-item[muted] .sound-overlay {\r\n    background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"18px\" height=\"18px\" viewBox=\"0 0 18 18\"><path fill-opacity=\"context-fill-opacity\" fill=\"context-fill\" d=\"M3.52,5.367c-1.332,0-2.422,1.09-2.422,2.422v2.422c0,1.332,1.09,2.422,2.422,2.422h1.516l4.102,3.633V1.735L5.035,5.367H3.52z\"/><path fill=\"context-fill\" fill-rule=\"evenodd\" d=\"M12.155,12.066l-1.138-1.138l4.872-4.872l1.138,1.138 L12.155,12.066z\"/><path fill=\"context-fill\" fill-rule=\"evenodd\" d=\"M10.998,7.204l1.138-1.138l4.872,4.872l-1.138,1.138L10.998,7.204z\"/></svg>')\r\n        center/12px no-repeat;\r\n}\r\n#vertical-tabs-pane[unpinned] .all-tabs-item[activemedia-blocked] .sound-overlay {\r\n    background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16px\" height=\"16px\" viewBox=\"0 0 12 12\" fill-opacity=\"context-fill-opacity\" fill=\"context-fill\"><path d=\"M2.128.13A.968.968 0 0 0 .676.964v10.068a.968.968 0 0 0 1.452.838l8.712-5.034a.968.968 0 0 0 0-1.676L2.128.13z\"/></svg>')\r\n        3px 3px/9px no-repeat;\r\n}\r\n/* take a chunk out of the favicon so the overlay is more visible */\r\n#vertical-tabs-pane\r\n    .all-tabs-item:is([muted], [soundplaying], [activemedia-blocked])\r\n    .all-tabs-button\r\n    .toolbarbutton-icon {\r\n    mask: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"100%\" cy=\"100%\" r=\"9\"/></svg>')\r\n            exclude 0/100% 100% no-repeat,\r\n        linear-gradient(#fff, #fff);\r\n    mask-position: 8px 8px;\r\n    transition-property: mask;\r\n    transition-timing-function: ease-in-out;\r\n    transition-duration: calc(var(--pane-transition-duration) / 2);\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded])\r\n    .all-tabs-item:is([muted], [soundplaying], [activemedia-blocked])\r\n    .all-tabs-button\r\n    .toolbarbutton-icon {\r\n    mask: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\"><circle cx=\"100%\" cy=\"100%\" r=\"9\"/></svg>')\r\n            exclude 0/100% 100% no-repeat,\r\n        linear-gradient(#fff, #fff);\r\n}\r\n/* close button */\r\n#vertical-tabs-list .all-tabs-item .all-tabs-secondary-button[close-button] {\r\n    fill-opacity: 0;\r\n    transform: translateX(14px);\r\n    opacity: 0;\r\n    margin-inline-start: -27px;\r\n    transition: 0.25s cubic-bezier(0.07, 0.78, 0.21, 0.95) transform,\r\n        0.2s cubic-bezier(0.07, 0.74, 0.24, 0.95) margin, 0.075s linear opacity;\r\n    display: block;\r\n    -moz-context-properties: fill, fill-opacity, stroke;\r\n    fill: currentColor;\r\n    fill-opacity: 0;\r\n    border-radius: var(--tab-button-border-radius, 2px);\r\n    list-style-image: url(\"data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='20' height='20'><rect fill='context-fill' fill-opacity='context-fill-opacity' width='20' height='20' rx='2' ry='2'/><path fill='context-fill' fill-opacity='context-stroke-opacity' d='M11.06 10l3.47-3.47a.75.75 0 00-1.06-1.06L10 8.94 6.53 5.47a.75.75 0 10-1.06 1.06L8.94 10l-3.47 3.47a.75.75 0 101.06 1.06L10 11.06l3.47 3.47a.75.75 0 001.06-1.06z'/></svg>\");\r\n}\r\n#vertical-tabs-list\r\n    .all-tabs-item:is(:hover, :focus-within)\r\n    .all-tabs-secondary-button[close-button] {\r\n    transform: none;\r\n    opacity: 0.7;\r\n    margin-inline-start: -2px;\r\n}\r\n/* drag/drop indicator */\r\n#vertical-tabs-list .all-tabs-item[dragpos] {\r\n    background-color: color-mix(\r\n        in srgb,\r\n        transparent 30%,\r\n        var(--arrowpanel-faint, color-mix(in srgb, var(--arrowpanel-dimmed) 60%, transparent))\r\n    );\r\n}\r\n#vertical-tabs-list .all-tabs-item[dragpos]::before {\r\n    content: \"\";\r\n    position: absolute;\r\n    pointer-events: none;\r\n    height: 0;\r\n    z-index: 1000;\r\n    width: 100%;\r\n}\r\n#vertical-tabs-pane:not([no-expand][unpinned]) #vertical-tabs-list .all-tabs-item[dragpos]::before {\r\n    border-image: linear-gradient(\r\n        to right,\r\n        transparent,\r\n        var(--arrowpanel-dimmed-even-further) 1%,\r\n        var(--arrowpanel-dimmed-even-further) 25%,\r\n        transparent 90%\r\n    );\r\n    border-image-slice: 1;\r\n}\r\n#vertical-tabs-list .all-tabs-item[dragpos=\"before\"]::before {\r\n    inset-block-start: 0;\r\n    border-top: 1px solid var(--arrowpanel-dimmed-even-further);\r\n}\r\n#vertical-tabs-list .all-tabs-item[dragpos=\"after\"]::before {\r\n    inset-block-end: 0;\r\n    border-bottom: 1px solid var(--arrowpanel-dimmed-even-further);\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded])\r\n    #vertical-tabs-list\r\n    .all-tabs-item\r\n    .all-tabs-secondary-button[toggle-mute] {\r\n    transform: none !important;\r\n    margin-inline: revert !important;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded]) .all-tabs-item {\r\n    min-width: 0 !important;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded]) :is(.all-tabs-item, .subviewbutton) {\r\n    margin: 0 !important;\r\n    -moz-box-pack: start !important;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([no-expand])\r\n    #vertical-tabs-buttons-row\r\n    > toolbarbutton:not(#vertical-tabs-new-tab-button),\r\n#vertical-tabs-pane[unpinned] :is(.all-tabs-item, .subviewbutton) .toolbarbutton-text {\r\n    transition-property: opacity;\r\n    transition-timing-function: ease-in-out;\r\n    transition-duration: var(--pane-transition-duration);\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded]) .all-tabs-secondary-button {\r\n    visibility: collapse;\r\n}\r\n#vertical-tabs-pane[unpinned]:not([expanded], [no-expand])\r\n    #vertical-tabs-buttons-row\r\n    > toolbarbutton:not(#vertical-tabs-new-tab-button),\r\n#vertical-tabs-pane[unpinned]:not([expanded])\r\n    :is(.all-tabs-item, .subviewbutton)\r\n    .toolbarbutton-text {\r\n    opacity: 0 !important;\r\n}\r\n#vertical-tabs-pane .subviewbutton-iconic > .toolbarbutton-icon {\r\n    -moz-context-properties: fill, fill-opacity;\r\n}\r\n#vertical-tabs-pane .subviewbutton.no-label .toolbarbutton-text {\r\n    display: none;\r\n}\r\n/* pinned indicator */\r\n#vertical-tabs-pane .all-tabs-item[pinned] > .all-tabs-button.subviewbutton > .toolbarbutton-text {\r\n    background: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path fill=\"context-fill\" fill-opacity=\"context-fill-opacity\" d=\"M14.707 13.293L11.414 10l2.293-2.293a1 1 0 0 0 0-1.414A4.384 4.384 0 0 0 10.586 5h-.172A2.415 2.415 0 0 1 8 2.586V2a1 1 0 0 0-1.707-.707l-5 5A1 1 0 0 0 2 8h.586A2.415 2.415 0 0 1 5 10.414v.169a4.036 4.036 0 0 0 1.337 3.166 1 1 0 0 0 1.37-.042L10 11.414l3.293 3.293a1 1 0 0 0 1.414-1.414zm-7.578-1.837A2.684 2.684 0 0 1 7 10.583v-.169a4.386 4.386 0 0 0-1.292-3.121 4.414 4.414 0 0 0-1.572-1.015l2.143-2.142a4.4 4.4 0 0 0 1.013 1.571A4.384 4.384 0 0 0 10.414 7h.172a2.4 2.4 0 0 1 .848.152z\"/></svg>')\r\n        no-repeat 6px/11px;\r\n    padding-inline-start: 20px;\r\n    -moz-context-properties: fill, fill-opacity;\r\n    fill: currentColor;\r\n}\r\n#vertical-tabs-pane toolbarseparator {\r\n    appearance: none;\r\n    min-height: 0;\r\n    border-top: 1px solid var(--panel-separator-color);\r\n    border-bottom: none;\r\n    margin: var(--panel-separator-margin);\r\n    margin-inline: 0;\r\n    padding: 0;\r\n}\r\n#vertical-tabs-pane[checked] toolbartabstop {\r\n    -moz-user-focus: normal;\r\n}\r\n/* the main toolbar button */\r\n#vertical-tabs-button {\r\n    list-style-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"context-fill %230c0c0d\"><path fill-opacity=\"context-fill-opacity\" d=\"M2,7h3v6H2V7z\"/><path d=\"M6,7v6H5V7H2V6h12v1H6z M13,1c1.657,0,3,1.343,3,3v8c0,1.657-1.343,3-3,3H3c-1.657,0-3-1.343-3-3V4c0-1.657,1.343-3,3-3H13z M3,3C2.448,3,2,3.448,2,4v8c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V4c0-0.6-0.4-1-1-1H3z\"/></svg>');\r\n    fill-opacity: 0.4;\r\n}\r\n/* buttons at the top of the pane */\r\n#vertical-tabs-button:not([positionstart=\"true\"]) .toolbarbutton-icon {\r\n    transform: scaleX(-1);\r\n}\r\n#vertical-tabs-button[checked],\r\n#vertical-tabs-close-button {\r\n    list-style-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\" fill=\"context-fill %230c0c0d\"><path fill-opacity=\"context-fill-opacity\" d=\"M2,3h12v3H2V3z\"/><path d=\"M6,7v6H5V7H2V6h12v1H6z M13,1c1.657,0,3,1.343,3,3v8c0,1.657-1.343,3-3,3H3c-1.657,0-3-1.343-3-3V4c0-1.657,1.343-3,3-3H13z M3,3C2.448,3,2,3.448,2,4v8c0,0.6,0.4,1,1,1h10c0.6,0,1-0.4,1-1V4c0-0.6-0.4-1-1-1H3z\"/></svg>');\r\n    fill-opacity: 0.4;\r\n}\r\n#vertical-tabs-new-tab-button {\r\n    list-style-image: url(\"chrome://browser/skin/new-tab.svg\");\r\n}\r\n#vertical-tabs-pin-button {\r\n    list-style-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path fill=\"context-fill\" fill-opacity=\"context-fill-opacity\" d=\"M11.414 10l2.293-2.293a1 1 0 0 0 0-1.414 4.418 4.418 0 0 0-.8-.622L11.425 7.15h.008l-4.3 4.3v-.017l-1.48 1.476a3.865 3.865 0 0 0 .692.834 1 1 0 0 0 1.37-.042L10 11.414l3.293 3.293a1 1 0 0 0 1.414-1.414zm3.293-8.707a1 1 0 0 0-1.414 0L9.7 4.882A2.382 2.382 0 0 1 8 2.586V2a1 1 0 0 0-1.707-.707l-5 5A1 1 0 0 0 2 8h.586a2.382 2.382 0 0 1 2.3 1.7l-3.593 3.593a1 1 0 1 0 1.414 1.414l12-12a1 1 0 0 0 0-1.414zm-9 6a4.414 4.414 0 0 0-1.571-1.015l2.143-2.142a4.4 4.4 0 0 0 1.013 1.571 4.191 4.191 0 0 0 .9.684l-1.8 1.8a4.2 4.2 0 0 0-.684-.898z\"/></svg>');\r\n}\r\n#vertical-tabs-pane[unpinned] #vertical-tabs-pin-button {\r\n    list-style-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\" viewBox=\"0 0 16 16\"><path fill=\"context-fill\" fill-opacity=\"context-fill-opacity\" d=\"M14.707 13.293L11.414 10l2.293-2.293a1 1 0 0 0 0-1.414A4.384 4.384 0 0 0 10.586 5h-.172A2.415 2.415 0 0 1 8 2.586V2a1 1 0 0 0-1.707-.707l-5 5A1 1 0 0 0 2 8h.586A2.415 2.415 0 0 1 5 10.414v.169a4.036 4.036 0 0 0 1.337 3.166 1 1 0 0 0 1.37-.042L10 11.414l3.293 3.293a1 1 0 0 0 1.414-1.414zm-7.578-1.837A2.684 2.684 0 0 1 7 10.583v-.169a4.386 4.386 0 0 0-1.292-3.121 4.414 4.414 0 0 0-1.572-1.015l2.143-2.142a4.4 4.4 0 0 0 1.013 1.571A4.384 4.384 0 0 0 10.414 7h.172a2.4 2.4 0 0 1 .848.152z\"/></svg>');\r\n}\r\n#vertical-tabs-tooltip > .places-tooltip-box > hbox {\r\n    -moz-box-align: center;\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon {\r\n    min-width: 1em;\r\n    min-height: 1em;\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[hidden] {\r\n    display: none;\r\n}\r\n@supports -moz-bool-pref(\"userChrome.tabs.tooltip.always-show-lock-icon\") {\r\n    #vertical-tabs-tooltip #places-tooltip-insecure-icon {\r\n        display: -moz-inline-box !important;\r\n    }\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[pending] {\r\n    display: none !important;\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"secure\"] {\r\n    list-style-image: url(\"chrome://global/skin/icons/security.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"insecure\"] {\r\n    list-style-image: url(\"chrome://global/skin/icons/security-broken.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"mixed-passive\"] {\r\n    list-style-image: url(\"chrome://global/skin/icons/security-warning.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"about-page\"] {\r\n    list-style-image: url('data:image/svg+xml;utf8,<svg xmlns=\"http://www.w3.org/2000/svg\" width=\"16\" height=\"16\"><path fill=\"context-fill\" fill-opacity=\"context-fill-opacity\" d=\"M15.424 5.366A4.384 4.384 0 0 0 13.817 3.4a7.893 7.893 0 0 1 .811 2.353v.017c-.9-2.185-2.441-3.066-3.7-4.984l-.189-.3c-.035-.059-.063-.112-.088-.161a1.341 1.341 0 0 1-.119-.306.022.022 0 0 0-.013-.019.026.026 0 0 0-.019 0h-.006a5.629 5.629 0 0 0-2.755 4.308c.094-.006.187-.014.282-.014a4.069 4.069 0 0 1 3.51 1.983A2.838 2.838 0 0 0 9.6 5.824a3.2 3.2 0 0 1-1.885 6.013 3.651 3.651 0 0 1-1.042-.2c-.078-.028-.157-.059-.235-.093-.046-.02-.091-.04-.135-.062A3.282 3.282 0 0 1 4.415 8.95s.369-1.334 2.647-1.334a1.91 1.91 0 0 0 .964-.857 12.756 12.756 0 0 1-1.941-1.118c-.29-.277-.428-.411-.551-.511-.066-.054-.128-.1-.207-.152a3.481 3.481 0 0 1-.022-1.894 5.915 5.915 0 0 0-1.929 1.442A4.108 4.108 0 0 1 3.1 2.584a1.561 1.561 0 0 0-.267.138 5.767 5.767 0 0 0-.783.649 6.9 6.9 0 0 0-.748.868 6.446 6.446 0 0 0-1.08 2.348c0 .009-.076.325-.131.715l-.025.182c-.019.117-.033.245-.048.444v.023c-.005.076-.011.16-.016.258v.04A7.884 7.884 0 0 0 8.011 16a7.941 7.941 0 0 0 7.9-6.44l.036-.3a7.724 7.724 0 0 0-.523-3.894z\" /></svg>');\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"local-page\"] {\r\n    list-style-image: url(\"chrome://browser/skin/notification-icons/persistent-storage.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"extension-page\"] {\r\n    list-style-image: url(\"chrome://browser/content/extension.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"home-page\"] {\r\n    list-style-image: url(\"chrome://browser/skin/tab.svg\");\r\n}\r\n#vertical-tabs-tooltip #places-tooltip-insecure-icon[type=\"error-page\"] {\r\n    list-style-image: url(\"chrome://global/skin/icons/warning.svg\");\r\n}\r\n            `;\r\n                let sss = Cc[\"@mozilla.org/content/style-sheet-service;1\"].getService(\r\n                    Ci.nsIStyleSheetService\r\n                );\r\n                let uri = makeURI(\"data:text/css;charset=UTF=8,\" + encodeURIComponent(css));\r\n                if (sss.sheetRegistered(uri, sss.AUTHOR_SHEET)) return; // avoid loading duplicate sheets on subsequent window launches.\r\n                sss.loadAndRegisterSheet(uri, sss.AUTHOR_SHEET);\r\n            }\r\n            // there's a firefox bug where menuitems in the tab context menu don't have their localized labels initialized until the menu is opened on the *actual* tab bar.\r\n            // this bug actually affects the all-tabs menu but would affect anything trying to use the tab context menu that isn't the real tab bar.\r\n            // so we de-lazify the l10n IDs ourselves. lazy IDs are used for things that don't need to be managed at startup,\r\n            // but since we're increasing the number of elements that use this context menu, it's now pertinent to do this at startup.\r\n        l10nIfNeeded() {\r\n                let lazies = document\r\n                    .getElementById(\"tabContextMenu\")\r\n                    .querySelectorAll(\"[data-lazy-l10n-id]\");\r\n                if (lazies) {\r\n                    MozXULElement.insertFTLIfNeeded(\"browser/tabContextMenu.ftl\");\r\n                    lazies.forEach((el) => {\r\n                        el.setAttribute(\"data-l10n-id\", el.getAttribute(\"data-lazy-l10n-id\"));\r\n                        el.removeAttribute(\"data-lazy-l10n-id\");\r\n                    });\r\n                }\r\n            }\r\n            // what to do when a window is closed. if it's the last window, record data about the pane's state to the xulStore and prefs.\r\n        uninit() {\r\n            let enumerator = Services.wm.getEnumerator(\"navigator:browser\");\r\n            if (!enumerator.hasMoreElements()) {\r\n                let xulStore = Services.xulStore;\r\n                if (this.pane.hasAttribute(\"checked\")) xulStore.persist(this.pane, \"checked\");\r\n                else xulStore.removeValue(document.documentURI, \"vertical-tabs-pane\", \"checked\");\r\n                xulStore.persist(this.pane, \"width\");\r\n                prefSvc.setBoolPref(closedPref, this.pane.hidden || false);\r\n                prefSvc.setBoolPref(unpinnedPref, this.pane.getAttribute(\"unpinned\") || false);\r\n                prefSvc.setIntPref(widthPref, this.pane.width || 350);\r\n            }\r\n        }\r\n    }\r\n\r\n    // invoked when delayed window startup has finished, in other words after important components have been fully inited.\r\n    function init() {\r\n        window.verticalTabsPane = new VerticalTabsPaneBase(); // instantiate our tabs pane\r\n        SidebarUI.setPosition(); // set the sidebar position again since we modified this function, probably after it already set the position\r\n        // change the onUnload function (invoked when window is closed) so that it calls our uninit function too.\r\n        eval(\r\n            `gBrowserInit.onUnload = function ` +\r\n            gBrowserInit.onUnload\r\n            .toSource()\r\n            .replace(/(SidebarUI\\.uninit\\(\\))/, `$1; verticalTabsPane.uninit()`)\r\n        );\r\n        window.onunload = gBrowserInit.onUnload.bind(gBrowserInit); // reset the event handler since it used the bind method, which creates an anonymous version of the function that we can't change. just re-bind our new version.\r\n        let gNextWindowID = 0; // looks unread but this is required for the following functions\r\n        // make the PictureInPicture methods dispatch an event to the tab container informing us that a tab's \"pictureinpicture\" attribute has changed.\r\n        // this is how we capture all changes to the sound icon in real-time. obviously this behavior isn't built-in, I guess for sake of brevity.\r\n        let handleRequestSrc = PictureInPicture.handlePictureInPictureRequest.toSource();\r\n        if (!handleRequestSrc.includes(\"_tabAttrModified\"))\r\n            eval(\r\n                `PictureInPicture.handlePictureInPictureRequest = async function ` +\r\n                handleRequestSrc\r\n                .replace(/async handlePictureInPictureRequest/, \"\")\r\n                .replace(/\\sServices\\.telemetry.*\\s*.*\\s*.*\\s*.*/, \"\")\r\n                .replace(/gCurrentPlayerCount.*/g, \"\")\r\n                .replace(\r\n                    /(tab\\.setAttribute\\(\\\"pictureinpicture\\\".*)/,\r\n                    `$1 parentWin.gBrowser._tabAttrModified(tab, [\"pictureinpicture\"]);`\r\n                )\r\n            );\r\n        let clearIconSrc = PictureInPicture.clearPipTabIcon.toSource();\r\n        if (!clearIconSrc.includes(\"_tabAttrModified\"))\r\n            eval(\r\n                `PictureInPicture.clearPipTabIcon = function ` +\r\n                clearIconSrc\r\n                .replace(/WINDOW\\_TYPE/, `\"Toolkit:PictureInPicture\"`)\r\n                .replace(\r\n                    /(tab\\.removeAttribute\\(\\\"pictureinpicture\\\".*)/,\r\n                    `$1 gBrowser._tabAttrModified(tab, [\"pictureinpicture\"]);`\r\n                )\r\n            );\r\n    }\r\n\r\n    // create the main button that goes in the tabs toolbar and opens the pane.\r\n    function makeWidget() {\r\n        // if you create a widget in the first window, it will automatically be created in subsequent videos.\r\n        // so we stop the script from re-registering it on every subsequent window load.\r\n        if (CustomizableUI.getPlacementOfWidget(\"vertical-tabs-button\", true)) return;\r\n        CustomizableUI.createWidget({\r\n            id: \"vertical-tabs-button\",\r\n            type: \"button\",\r\n            defaultArea: CustomizableUI.AREA_TABSTRIP, // it should go in the tabs toolbar by default but can be moved to any customizable toolbar.\r\n            label: config.l10n[\"Button label\"],\r\n            tooltiptext: config.l10n[\"Button tooltip\"],\r\n            localized: false,\r\n            onCommand(e) {\r\n                Services.obs.notifyObservers(e.target.ownerGlobal, \"vertical-tabs-pane-toggle\");\r\n            },\r\n            onCreated(node) {\r\n                // an <observes> element is how we get the button to appear \"checked\" when the tabs pane is checked.\r\n                // it automatically sets its parent's specified attribute (\"checked\" and \"positionstart\") to match that of whatever it's observing.\r\n                let doc = node.ownerDocument;\r\n                node.appendChild(\r\n                    create(doc, \"observes\", {\r\n                        \"element\": \"vertical-tabs-pane\",\r\n                        \"attribute\": \"checked\",\r\n                    })\r\n                );\r\n                node.appendChild(\r\n                    create(doc, \"observes\", {\r\n                        \"element\": \"vertical-tabs-pane\",\r\n                        \"attribute\": \"positionstart\",\r\n                    })\r\n                );\r\n                if (key_toggleVerticalTabs)\r\n                    node.tooltipText += ` (${ShortcutUtils.prettifyShortcut(\r\n                        key_toggleVerticalTabs\r\n                    )})`;\r\n            },\r\n        });\r\n    }\r\n\r\n    // make the hotkey (ctrl + alt + V)\r\n    if (config.hotkey.enabled && _ucUtils ? .registerHotkey)\r\n        _ucUtils.registerHotkey({\r\n                id: \"key_toggleVerticalTabs\",\r\n                modifiers: config.hotkey.modifiers,\r\n                key: config.hotkey.key,\r\n            },\r\n            (win, key) => Services.obs.notifyObservers(win, \"vertical-tabs-pane-toggle\")\r\n        );\r\n\r\n    // make the main elements\r\n    document.getElementById(\"sidebar-splitter\").after(\r\n        create(document, \"splitter\", {\r\n            class: \"chromeclass-extrachrome sidebar-splitter\",\r\n            id: \"vertical-tabs-splitter\",\r\n            hidden: true,\r\n        })\r\n    );\r\n    document.getElementById(\"sidebar-splitter\").after(\r\n        create(document, \"vbox\", {\r\n            class: \"chromeclass-extrachrome\",\r\n            id: \"vertical-tabs-pane\",\r\n            context: \"vertical-tabs-context-menu\",\r\n            hidden: true,\r\n        })\r\n    );\r\n\r\n    makeWidget();\r\n\r\n    // tab pane's horizontal alignment should mirror that of the sidebar, which can be moved from left to right.\r\n    SidebarUI.setPosition = function() {\r\n        let appcontent = document.getElementById(\"appcontent\");\r\n        let verticalSplitter = document.getElementById(\"vertical-tabs-splitter\");\r\n        let verticalPane = document.getElementById(\"vertical-tabs-pane\");\r\n        this._box.style.MozBoxOrdinalGroup = 1;\r\n        this._splitter.style.MozBoxOrdinalGroup = 2;\r\n        appcontent.style.MozBoxOrdinalGroup = 3;\r\n        verticalSplitter.style.MozBoxOrdinalGroup = 4;\r\n        verticalPane.style.MozBoxOrdinalGroup = 5;\r\n        if (!this._positionStart) {\r\n            this._box.style.MozBoxOrdinalGroup = 5;\r\n            this._splitter.style.MozBoxOrdinalGroup = 4;\r\n            verticalSplitter.style.MozBoxOrdinalGroup = 2;\r\n            verticalPane.style.MozBoxOrdinalGroup = 1;\r\n            this._box.setAttribute(\"positionend\", true);\r\n            verticalPane.setAttribute(\"positionstart\", true);\r\n        } else {\r\n            this._box.removeAttribute(\"positionend\");\r\n            verticalPane.removeAttribute(\"positionstart\");\r\n        }\r\n        this.hideSwitcherPanel();\r\n        let content = SidebarUI.browser.contentWindow;\r\n        if (content && content.updatePosition) content.updatePosition();\r\n    };\r\n\r\n    // wait for delayed startup for some parts of the script to execute.\r\n    if (gBrowserInit.delayedStartupFinished) init();\r\n    else {\r\n        let delayedListener = (subject, topic) => {\r\n            if (topic == \"browser-delayed-startup-finished\" && subject == window) {\r\n                Services.obs.removeObserver(delayedListener, topic);\r\n                init();\r\n            }\r\n        };\r\n        Services.obs.addObserver(delayedListener, \"browser-delayed-startup-finished\");\r\n    }\r\n})();"
        }
    ]
}