{
    "sourceFile": "utils/boot.jsm",
    "activeCommit": 0,
    "commits": [
        {
            "activePatchIndex": 1,
            "patches": [
                {
                    "date": 1649508267114,
                    "content": "Index: \n===================================================================\n--- \n+++ \n"
                },
                {
                    "date": 1652273041807,
                    "content": "Index: \n===================================================================\n--- \n+++ \n@@ -41,11 +41,8 @@\n   },\n   removeListener: (a) => Services.prefs.removeObserver(a.pref, a.observer),\n };\n \n-const SHARED_GLOBAL = {};\n-Object.defineProperty(SHARED_GLOBAL, \"widgetCallbacks\", { value: new Map() });\n-\n function resolveChromeURL(str) {\n   const registry = Cc[\"@mozilla.org/chrome/chrome-registry;1\"].getService(\n     Ci.nsIChromeRegistry\n   );\n@@ -57,667 +54,729 @@\n     console.error(e);\n     return \"\";\n   }\n }\n+\n // relative to \"chrome\" folder\n function resolveChromePath(str) {\n   let parts = resolveChromeURL(str).split(\"/\");\n   return parts.slice(parts.indexOf(\"chrome\") + 1, parts.length - 1).join(\"/\");\n }\n \n-let _uc = {\n-  BROWSERCHROME: \"chrome://browser/content/browser.xhtml\",\n-  PREF_ENABLED: \"userChromeJS.enabled\",\n-  PREF_SCRIPTSDISABLED: \"userChromeJS.scriptsDisabled\",\n+const SHARED_GLOBAL = {};\n+Object.defineProperty(SHARED_GLOBAL, \"widgetCallbacks\", { value: new Map() });\n \n-  SCRIPT_DIR: resolveChromePath(\"chrome://userscripts/content/\"),\n-  RESOURCE_DIR: resolveChromePath(\"chrome://userchrome/content/\"),\n-  BASE_FILEURI: Services.io\n-    .getProtocolHandler(\"file\")\n-    .QueryInterface(Ci.nsIFileProtocolHandler)\n-    .getURLSpecFromDir(Services.dirsvc.get(\"UChrm\", Ci.nsIFile)),\n+const BROWSERCHROME = \"chrome://browser/content/browser.xhtml\";\n+const PREF_ENABLED = \"userChromeJS.enabled\";\n+const PREF_SCRIPTSDISABLED = \"userChromeJS.scriptsDisabled\";\n+const PREF_GBROWSERHACKENABLED = \"userChromeJS.gBrowser_hack.enabled\";\n+const SCRIPT_DIR = resolveChromePath(\"chrome://userscripts/content/\");\n+const RESOURCE_DIR = resolveChromePath(\"chrome://userchrome/content/\");\n+const BASE_FILEURI = Services.io\n+  .getProtocolHandler(\"file\")\n+  .QueryInterface(Ci.nsIFileProtocolHandler)\n+  .getURLSpecFromDir(Services.dirsvc.get(\"UChrm\", Ci.nsIFile));\n \n-  SESSION_RESTORED: false,\n+class ScriptData {\n+  constructor(leafName, headerText) {\n+    this.filename = leafName;\n+    this.name = headerText.match(/\\/\\/ @name\\s+(.+)\\s*$/im)?.[1];\n+    this.charset = headerText.match(/\\/\\/ @charset\\s+(.+)\\s*$/im)?.[1];\n+    this.description = headerText.match(/\\/\\/ @description\\s+(.+)\\s*$/im)?.[1];\n+    this.version = headerText.match(/\\/\\/ @version\\s+(.+)\\s*$/im)?.[1];\n+    this.author = headerText.match(/\\/\\/ @author\\s+(.+)\\s*$/im)?.[1];\n+    this.homepageURL = headerText.match(/\\/\\/ @homepageURL\\s+(.+)\\s*$/im)?.[1];\n+    this.downloadURL = headerText.match(/\\/\\/ @downloadURL\\s+(.+)\\s*$/im)?.[1];\n+    this.updateURL = headerText.match(/\\/\\/ @updateURL\\s+(.+)\\s*$/im)?.[1];\n+    this.optionsURL = headerText.match(/\\/\\/ @optionsURL\\s+(.+)\\s*$/im)?.[1];\n+    this.startup = headerText.match(/\\/\\/ @startup\\s+(.+)\\s*$/im)?.[1];\n+    this.id =\n+      headerText.match(/\\/\\/ @id\\s+(.+)\\s*$/im)?.[1] ||\n+      `${leafName.split(\".uc.js\")[0]}@${this.author || \"userChromeJS\"}`;\n \n-  get chromeDir() {\n-    return Services.dirsvc.get(\"UChrm\", Ci.nsIFile);\n-  },\n+    this.onlyonce = /\\/\\/ @onlyonce\\b/.test(headerText);\n+    this.inbackground = /\\/\\/ @backgroundmodule\\b/.test(headerText);\n+    this.ignoreCache = /\\/\\/ @ignorecache\\b/.test(headerText);\n+    this.isRunning = false;\n \n-  getDirEntry: function (filename, isLoader = false) {\n-    filename = filename.replace(\"\\\\\", \"/\");\n-    let pathParts = (\n-      (filename.startsWith(\"..\")\n-        ? \"\"\n-        : isLoader\n-        ? _uc.SCRIPT_DIR\n-        : _uc.RESOURCE_DIR) +\n-      \"/\" +\n-      filename\n-    )\n-      .split(\"/\")\n-      .filter((a) => !!a && a != \"..\");\n-    let entry = _uc.chromeDir;\n-\n-    for (let part of pathParts) {\n-      entry.append(part);\n-    }\n-    if (!entry.exists()) {\n-      return null;\n-    }\n-    if (entry.isDirectory()) {\n-      return entry.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n-    } else if (entry.isFile()) {\n-      return entry;\n-    } else {\n-      return null;\n-    }\n-  },\n-\n-  updateStyleSheet: function (name, type) {\n-    if (type) {\n-      let sss = Cc[\"@mozilla.org/content/style-sheet-service;1\"].getService(\n-        Ci.nsIStyleSheetService\n-      );\n-      try {\n-        let uri = Services.io.newURI(`chrome://userchrome/content/${name}`);\n-        switch (type) {\n-          case \"agent\":\n-            sss.unregisterSheet(uri, sss.AGENT_SHEET);\n-            sss.loadAndRegisterSheet(uri, sss.AGENT_SHEET);\n-            return true;\n-          case \"author\":\n-            sss.unregisterSheet(uri, sss.AUTHOR_SHEET);\n-            sss.loadAndRegisterSheet(uri, sss.AUTHOR_SHEET);\n-            return true;\n-          default:\n-            return false;\n-        }\n-      } catch (e) {\n-        console.error(e);\n-        return false;\n-      }\n-    }\n-    let entry = _uc.utils.getFSEntry(name);\n-    if (!(entry && entry.isFile())) {\n-      return false;\n-    }\n-    let recentWindow = Services.wm.getMostRecentBrowserWindow();\n-    if (!recentWindow) {\n-      return false;\n-    }\n-    function recurseImports(sheet, all) {\n-      let z = 0;\n-      let rule = sheet.cssRules[0];\n-      // loop through import rules and check that the \"all\"\n-      // doesn't already contain the same object\n-      while (rule instanceof CSSImportRule && !all.includes(rule.styleSheet)) {\n-        all.push(rule.styleSheet);\n-        recurseImports(rule.styleSheet, all);\n-        rule = sheet.cssRules[++z];\n-      }\n-      return all;\n-    }\n-\n-    let sheets = recentWindow.InspectorUtils.getAllStyleSheets(\n-      recentWindow.document,\n-      false\n-    );\n-\n-    sheets = sheets.flatMap((x) => recurseImports(x, [x]));\n-\n-    // If a sheet is imported multiple times, then there will be\n-    // duplicates, because style system does create an object for\n-    // each instace but that's OK since sheets.find below will\n-    // only find the first instance and reload that which is\n-    // \"probably\" fine.\n-    let entryFilePath = `file:///${entry.path.replaceAll(\"\\\\\", \"/\")}`;\n-\n-    let target = sheets.find((sheet) => sheet.href === entryFilePath);\n-    if (target) {\n-      recentWindow.InspectorUtils.parseStyleSheet(\n-        target,\n-        _uc.utils.readFile(entry)\n-      );\n-      return true;\n-    }\n-    return false;\n-  },\n-\n-  getScripts: function () {\n-    this.scripts = {};\n-    if (!yPref.get(_uc.PREF_ENABLED) || !/^[\\w_]*$/.test(_uc.SCRIPT_DIR)) {\n-      console.log(\n-        \"Scripts are disabled or the given script directory name is invalid\"\n-      );\n-      return;\n-    }\n-    let files = _uc.getDirEntry(\"\", true);\n-    while (files.hasMoreElements()) {\n-      let file = files.getNext().QueryInterface(Ci.nsIFile);\n-      if (/\\.uc\\.js$/i.test(file.leafName)) {\n-        let script = _uc.getScriptData(file);\n-        if (script.inbackground && script.isEnabled) {\n-          try {\n-            Cu.import(`chrome://userscripts/content/${script.filename}`);\n-          } catch (e) {\n-            console.error(e);\n-          }\n-        }\n-      }\n-    }\n-  },\n-\n-  getScriptData: function (aFile) {\n-    let header = (_uc.utils\n-      .readFile(aFile, true)\n-      .match(\n-        /^\\/\\/ ==UserScript==\\s*\\n(?:.*\\n)*?\\/\\/ ==\\/UserScript==\\s*\\n/m\n-      ) || [\"\"])[0];\n+    // Construct regular expression to use to match target document\n     let match,\n       rex = {\n         include: [],\n         exclude: [],\n       };\n     let findNextRe = /^\\/\\/ @(include|exclude)\\s+(.+)\\s*$/gm;\n-    while ((match = findNextRe.exec(header))) {\n+    while ((match = findNextRe.exec(headerText))) {\n       rex[match[1]].push(\n-        match[2].replace(/^main$/i, _uc.BROWSERCHROME).replace(/\\*/g, \".*?\")\n+        match[2].replace(/^main$/i, BROWSERCHROME).replace(/\\*/g, \".*?\")\n       );\n     }\n     if (!rex.include.length) {\n-      rex.include.push(_uc.BROWSERCHROME);\n+      rex.include.push(BROWSERCHROME);\n     }\n     let exclude = rex.exclude.length ? `(?!${rex.exclude.join(\"$|\")}$)` : \"\";\n-    let def = [\"\", \"\"];\n-    let author = (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1];\n-    let filename = aFile.leafName || \"\";\n+    this.regex = new RegExp(\n+      `^${exclude}(${rex.include.join(\"|\") || \".*\"})$`,\n+      \"i\"\n+    );\n \n-    return (this.scripts[filename] = {\n-      filename: filename,\n-      name: (header.match(/\\/\\/ @name\\s+(.+)\\s*$/im) || def)[1],\n-      charset: (header.match(/\\/\\/ @charset\\s+(.+)\\s*$/im) || def)[1],\n-      description: (header.match(/\\/\\/ @description\\s+(.+)\\s*$/im) || def)[1],\n-      version: (header.match(/\\/\\/ @version\\s+(.+)\\s*$/im) || def)[1],\n-      author: (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1],\n-      regex: new RegExp(`^${exclude}(${rex.include.join(\"|\") || \".*\"})$`, \"i\"),\n-      id: (header.match(/\\/\\/ @id\\s+(.+)\\s*$/im) || [\n-        \"\",\n-        filename.split(\".uc.js\")[0] + \"@\" + (author || \"userChromeJS\"),\n-      ])[1],\n-      homepageURL: (header.match(/\\/\\/ @homepageURL\\s+(.+)\\s*$/im) || def)[1],\n-      downloadURL: (header.match(/\\/\\/ @downloadURL\\s+(.+)\\s*$/im) || def)[1],\n-      updateURL: (header.match(/\\/\\/ @updateURL\\s+(.+)\\s*$/im) || def)[1],\n-      optionsURL: (header.match(/\\/\\/ @optionsURL\\s+(.+)\\s*$/im) || def)[1],\n-      startup: (header.match(/\\/\\/ @startup\\s+(.+)\\s*$/im) || def)[1],\n-      onlyonce: /\\/\\/ @onlyonce\\b/.test(header),\n-      inbackground: /\\/\\/ @backgroundmodule\\b/.test(header),\n-      ignoreCache: /\\/\\/ @ignorecache\\b/.test(header),\n-      isRunning: false,\n-      get isEnabled() {\n-        return (\n-          (yPref.get(_uc.PREF_SCRIPTSDISABLED) || \"\")\n-            .split(\",\")\n-            .indexOf(this.filename) === -1\n-        );\n-      },\n-    });\n-  },\n-\n-  maybeRunStartUp: (script, win) => {\n-    if (\n-      script.startup &&\n-      /^\\w*$/.test(script.startup) &&\n-      SHARED_GLOBAL[script.startup] &&\n-      typeof SHARED_GLOBAL[script.startup]._startup === \"function\"\n-    ) {\n-      SHARED_GLOBAL[script.startup]._startup(win);\n+    if (this.inbackground) {\n+      this.loadOrder = -1;\n+    } else {\n+      let loadOrder = headerText.match(/\\/\\/ @loadOrder\\s+(\\d+)\\s*$/im)?.[1];\n+      this.loadOrder = Number.parseInt(loadOrder) || 10;\n     }\n-  },\n \n-  loadScript: function (script, win) {\n-    if (\n-      script.inbackground ||\n-      !script.regex.test(win.location.href) ||\n-      !script.isEnabled\n-    ) {\n+    Object.seal(this);\n+  }\n+  get isEnabled() {\n+    return (\n+      (yPref.get(PREF_SCRIPTSDISABLED) || \"\")\n+        .split(\",\")\n+        .indexOf(this.filename) === -1\n+    );\n+  }\n+\n+  tryLoadIntoWindow(win) {\n+    if (this.inbackground || !this.regex.test(win.location.href)) {\n       return;\n     }\n     try {\n-      if (script.onlyonce && script.isRunning) {\n-        _uc.maybeRunStartUp(script, win);\n+      if (this.onlyonce && this.isRunning) {\n+        if (this.startup) {\n+          SHARED_GLOBAL[this.startup]._startup(win);\n+        }\n         return;\n       }\n \n       Services.scriptloader.loadSubScriptWithOptions(\n-        `chrome://userscripts/content/${script.filename}`,\n+        `chrome://userscripts/content/${this.filename}`,\n         {\n           target: win,\n-          ignoreCache: script.ignoreCache,\n+          ignoreCache: this.ignoreCache,\n         }\n       );\n \n-      script.isRunning = true;\n-      _uc.maybeRunStartUp(script, win);\n+      this.isRunning = true;\n+      this.startup && SHARED_GLOBAL[this.startup]._startup(win);\n     } catch (ex) {\n-      console.error(ex);\n+      console.error(new Error(`@ ${this.filename}`, { cause: ex }));\n     }\n     return;\n-  },\n+  }\n \n-  // things to be exported for use by userscripts\n-  utils: {\n-    get sharedGlobal() {\n-      return SHARED_GLOBAL;\n-    },\n+  getInfo() {\n+    let info = { ...this };\n+    info.regex = new RegExp(this.regex.source, this.regex.flags);\n+    return info;\n+  }\n \n-    createElement: function (doc, tag, props, isHTML = false) {\n-      let el = isHTML ? doc.createElement(tag) : doc.createXULElement(tag);\n-      for (let prop in props) {\n-        el.setAttribute(prop, props[prop]);\n-      }\n-      return el;\n-    },\n+  static fromFile(aFile) {\n+    const headerText = utils\n+      .readFile(aFile, true)\n+      .match(/^\\/\\/ ==UserScript==\\s*\\n(?:.*\\n)*?\\/\\/ ==\\/UserScript==\\s*\\n/m);\n+    return new ScriptData(aFile.leafName, headerText ? headerText[0] : \"\");\n+  }\n+}\n \n-    createWidget(desc) {\n-      if (!desc || !desc.id) {\n-        console.error(\"custom widget description is missing 'id' property\");\n-        return null;\n-      }\n-      if (![\"toolbaritem\", \"toolbarbutton\"].includes(desc.type)) {\n-        console.error(\"custom widget has unsupported type: \" + desc.type);\n-        return null;\n-      }\n-      const CUI = Services.wm.getMostRecentBrowserWindow().CustomizableUI;\n-      let newWidget = CUI.getWidget(desc.id);\n+function getDirEntry(filename, isLoader = false) {\n+  if (typeof filename !== \"string\") {\n+    return null;\n+  }\n+  filename = filename.replace(\"\\\\\", \"/\");\n+  let pathParts = (\n+    (filename.startsWith(\"..\") ? \"\" : isLoader ? SCRIPT_DIR : RESOURCE_DIR) +\n+    \"/\" +\n+    filename\n+  )\n+    .split(\"/\")\n+    .filter((a) => !!a && a != \"..\");\n+  let entry = Services.dirsvc.get(\"UChrm\", Ci.nsIFile);\n \n-      if (newWidget && newWidget.hasOwnProperty(\"source\")) {\n-        // very likely means that the widget with this id already exists\n-        // There isn't a very reliable way to 'really' check if it exists or not\n-        return newWidget;\n+  for (let part of pathParts) {\n+    entry.append(part);\n+  }\n+  if (!entry.exists()) {\n+    return null;\n+  }\n+  if (entry.isDirectory()) {\n+    return entry.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n+  } else if (entry.isFile()) {\n+    return entry;\n+  } else {\n+    return null;\n+  }\n+}\n+\n+function updateStyleSheet(name, type) {\n+  if (type) {\n+    let sss = Cc[\"@mozilla.org/content/style-sheet-service;1\"].getService(\n+      Ci.nsIStyleSheetService\n+    );\n+    try {\n+      let uri = Services.io.newURI(`chrome://userchrome/content/${name}`);\n+      switch (type) {\n+        case \"agent\":\n+          sss.unregisterSheet(uri, sss.AGENT_SHEET);\n+          sss.loadAndRegisterSheet(uri, sss.AGENT_SHEET);\n+          return true;\n+        case \"author\":\n+          sss.unregisterSheet(uri, sss.AUTHOR_SHEET);\n+          sss.loadAndRegisterSheet(uri, sss.AUTHOR_SHEET);\n+          return true;\n+        default:\n+          return false;\n       }\n-      // This is pretty ugly but makes onBuild much cleaner.\n-      let itemStyle = \"\";\n-      if (desc.image) {\n-        if (desc.type === \"toolbarbutton\") {\n-          itemStyle += \"list-style-image:\";\n-        } else {\n-          itemStyle += \"background: transparent center no-repeat \";\n-        }\n-        itemStyle += `url(chrome://userChrome/content/${desc.image});`;\n-        itemStyle += desc.style || \"\";\n-      }\n-      SHARED_GLOBAL.widgetCallbacks.set(desc.id, desc.callback);\n+    } catch (e) {\n+      console.error(e);\n+      return false;\n+    }\n+  }\n+  let entry = getDirEntry(name);\n+  if (!(entry && entry.isFile())) {\n+    return false;\n+  }\n+  let recentWindow = Services.wm.getMostRecentBrowserWindow();\n+  if (!recentWindow) {\n+    return false;\n+  }\n+  function recurseImports(sheet, all) {\n+    let z = 0;\n+    let rule = sheet.cssRules[0];\n+    // loop through import rules and check that the \"all\"\n+    // doesn't already contain the same object\n+    while (rule instanceof CSSImportRule && !all.includes(rule.styleSheet)) {\n+      all.push(rule.styleSheet);\n+      recurseImports(rule.styleSheet, all);\n+      rule = sheet.cssRules[++z];\n+    }\n+    return all;\n+  }\n \n-      return CUI.createWidget({\n-        id: desc.id,\n-        type: \"custom\",\n-        onBuild: function (aDocument) {\n-          let toolbaritem = aDocument.createXULElement(desc.type);\n-          let props = {\n-            id: desc.id,\n-            class: `toolbarbutton-1 chromeclass-toolbar-additional ${\n-              desc.class ? desc.class : \"\"\n-            }`,\n-            overflows: !!desc.overflows,\n-            label: desc.label || desc.id,\n-            tooltiptext: desc.tooltip || desc.id,\n-            style: itemStyle,\n-            onclick: `${\n-              desc.allEvents ? \"\" : \"event.button===0 && \"\n-            }_ucUtils.sharedGlobal.widgetCallbacks.get(this.id)(event,window)`,\n-          };\n-          for (let p in props) {\n-            toolbaritem.setAttribute(p, props[p]);\n-          }\n-          return toolbaritem;\n-        },\n-      });\n-    },\n+  let sheets = recentWindow.InspectorUtils.getAllStyleSheets(\n+    recentWindow.document,\n+    false\n+  );\n \n-    readFile: function (aFile, metaOnly = false) {\n-      let stream = Cc[\n-        \"@mozilla.org/network/file-input-stream;1\"\n-      ].createInstance(Ci.nsIFileInputStream);\n-      let cvstream = Cc[\n-        \"@mozilla.org/intl/converter-input-stream;1\"\n-      ].createInstance(Ci.nsIConverterInputStream);\n-      try {\n-        stream.init(aFile, 0x01, 0, 0);\n-        cvstream.init(\n-          stream,\n-          \"UTF-8\",\n-          1024,\n-          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER\n-        );\n-      } catch (e) {\n-        console.error(e);\n-        return null;\n+  sheets = sheets.flatMap((x) => recurseImports(x, [x]));\n+\n+  // If a sheet is imported multiple times, then there will be\n+  // duplicates, because style system does create an object for\n+  // each instace but that's OK since sheets.find below will\n+  // only find the first instance and reload that which is\n+  // \"probably\" fine.\n+  let entryFilePath = `file:///${entry.path.replaceAll(\"\\\\\", \"/\")}`;\n+\n+  let target = sheets.find((sheet) => sheet.href === entryFilePath);\n+  if (target) {\n+    recentWindow.InspectorUtils.parseStyleSheet(target, utils.readFile(entry));\n+    return true;\n+  }\n+  return false;\n+}\n+\n+const utils = {\n+  get sharedGlobal() {\n+    return SHARED_GLOBAL;\n+  },\n+\n+  createElement: function (doc, tag, props, isHTML = false) {\n+    let el = isHTML ? doc.createElement(tag) : doc.createXULElement(tag);\n+    for (let prop in props) {\n+      el.setAttribute(prop, props[prop]);\n+    }\n+    return el;\n+  },\n+\n+  createWidget(desc) {\n+    if (!desc || !desc.id) {\n+      console.error(\"custom widget description is missing 'id' property\");\n+      return null;\n+    }\n+    if (![\"toolbaritem\", \"toolbarbutton\"].includes(desc.type)) {\n+      console.error(\"custom widget has unsupported type: \" + desc.type);\n+      return null;\n+    }\n+    const CUI = Services.wm.getMostRecentBrowserWindow().CustomizableUI;\n+    let newWidget = CUI.getWidget(desc.id);\n+\n+    if (newWidget && newWidget.hasOwnProperty(\"source\")) {\n+      // very likely means that the widget with this id already exists\n+      // There isn't a very reliable way to 'really' check if it exists or not\n+      return newWidget;\n+    }\n+    // This is pretty ugly but makes onBuild much cleaner.\n+    let itemStyle = \"\";\n+    if (desc.image) {\n+      if (desc.type === \"toolbarbutton\") {\n+        itemStyle += \"list-style-image:\";\n+      } else {\n+        itemStyle += \"background: transparent center no-repeat \";\n       }\n-      let content = \"\",\n-        data = {};\n-      while (cvstream.readString(4096, data)) {\n-        content += data.value;\n-        if (metaOnly && content.indexOf(\"// ==/UserScript==\") > 0) {\n-          break;\n+      itemStyle += `url(chrome://userChrome/content/${desc.image});`;\n+      itemStyle += desc.style || \"\";\n+    }\n+    SHARED_GLOBAL.widgetCallbacks.set(desc.id, desc.callback);\n+\n+    return CUI.createWidget({\n+      id: desc.id,\n+      type: \"custom\",\n+      onBuild: function (aDocument) {\n+        let toolbaritem = aDocument.createXULElement(desc.type);\n+        let props = {\n+          id: desc.id,\n+          class: `toolbarbutton-1 chromeclass-toolbar-additional ${\n+            desc.class ? desc.class : \"\"\n+          }`,\n+          overflows: !!desc.overflows,\n+          label: desc.label || desc.id,\n+          tooltiptext: desc.tooltip || desc.id,\n+          style: itemStyle,\n+          onclick: `${\n+            desc.allEvents ? \"\" : \"event.button===0 && \"\n+          }_ucUtils.sharedGlobal.widgetCallbacks.get(this.id)(event,window)`,\n+        };\n+        for (let p in props) {\n+          toolbaritem.setAttribute(p, props[p]);\n         }\n+        return toolbaritem;\n+      },\n+    });\n+  },\n+\n+  readFile: function (aFile, metaOnly = false) {\n+    if (typeof aFile === \"string\") {\n+      aFile = getDirEntry(aFile);\n+    }\n+    let stream = Cc[\"@mozilla.org/network/file-input-stream;1\"].createInstance(\n+      Ci.nsIFileInputStream\n+    );\n+    let cvstream = Cc[\n+      \"@mozilla.org/intl/converter-input-stream;1\"\n+    ].createInstance(Ci.nsIConverterInputStream);\n+    try {\n+      stream.init(aFile, 0x01, 0, 0);\n+      cvstream.init(\n+        stream,\n+        \"UTF-8\",\n+        1024,\n+        Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER\n+      );\n+    } catch (e) {\n+      console.error(e);\n+      return null;\n+    }\n+    let content = \"\",\n+      data = {};\n+    while (cvstream.readString(4096, data)) {\n+      content += data.value;\n+      if (metaOnly && content.indexOf(\"// ==/UserScript==\") > 0) {\n+        break;\n       }\n-      cvstream.close();\n-      stream.close();\n-      return content.replace(/\\r\\n?/g, \"\\n\");\n-    },\n+    }\n+    cvstream.close();\n+    stream.close();\n+    return content.replace(/\\r\\n?/g, \"\\n\");\n+  },\n \n-    createFileURI: (fileName = \"\") => {\n-      fileName = String(fileName);\n-      let u = resolveChromeURL(`chrome://userchrome/content/${fileName}`);\n-      return fileName ? u : u.substr(0, u.lastIndexOf(\"/\") + 1);\n-    },\n+  createFileURI: (fileName = \"\") => {\n+    fileName = String(fileName);\n+    let u = resolveChromeURL(`chrome://userchrome/content/${fileName}`);\n+    return fileName ? u : u.substr(0, u.lastIndexOf(\"/\") + 1);\n+  },\n \n-    get chromeDir() {\n-      return {\n-        get files() {\n-          return _uc.chromeDir.directoryEntries.QueryInterface(\n-            Ci.nsISimpleEnumerator\n-          );\n-        },\n-        uri: _uc.BASE_FILEURI,\n-      };\n-    },\n+  get chromeDir() {\n+    return {\n+      get files() {\n+        const dir = Services.dirsvc.get(\"UChrm\", Ci.nsIFile);\n+        return dir.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n+      },\n+      uri: BASE_FILEURI,\n+    };\n+  },\n \n-    getFSEntry: (fileName) => _uc.getDirEntry(fileName),\n+  getFSEntry: (fileName) => getDirEntry(fileName),\n \n-    getScriptData: () => {\n-      let scripts = [];\n-      for (let script in _uc.scripts) {\n-        let data = {};\n-        let o = _uc.scripts[script];\n-        for (let p in o) {\n-          if (p != \"isEnabled\") {\n-            data[p] = o[p];\n-          }\n+  getScriptData: () => {\n+    let scripts = [];\n+    const disabledScripts = (yPref.get(PREF_SCRIPTSDISABLED) || \"\").split(\",\");\n+    for (let script of _ucjs.scripts) {\n+      let scriptInfo = script.getInfo();\n+      scriptInfo.isEnabled = !disabledScripts.includes(script.filename);\n+      scripts.push(scriptInfo);\n+    }\n+    return scripts;\n+  },\n+\n+  get windows() {\n+    return {\n+      get: function (onlyBrowsers = true) {\n+        let windows = Services.wm.getEnumerator(\n+          onlyBrowsers ? \"navigator:browser\" : null\n+        );\n+        let wins = [];\n+        while (windows.hasMoreElements()) {\n+          wins.push(windows.getNext());\n         }\n-        scripts.push(data);\n-      }\n-      return scripts;\n-    },\n+        return wins;\n+      },\n+      forEach: function (fun, onlyBrowsers = true) {\n+        let wins = this.get(onlyBrowsers);\n+        wins.forEach((w) => fun(w.document, w));\n+      },\n+    };\n+  },\n \n-    get windows() {\n-      return {\n-        get: function (onlyBrowsers = true) {\n-          let windows = Services.wm.getEnumerator(\n-            onlyBrowsers ? \"navigator:browser\" : null\n-          );\n-          let wins = [];\n-          while (windows.hasMoreElements()) {\n-            wins.push(windows.getNext());\n-          }\n-          return wins;\n-        },\n-        forEach: function (fun, onlyBrowsers = true) {\n-          let wins = this.get(onlyBrowsers);\n-          wins.forEach((w) => fun(w.document, w));\n-        },\n-      };\n-    },\n+  toggleScript: function (el) {\n+    let isElement = !!el.tagName;\n+    if (!isElement && typeof el != \"string\") {\n+      return;\n+    }\n+    const name = isElement ? el.getAttribute(\"filename\") : el;\n+    let script = _ucjs.scripts.find((script) => script.filename === name);\n+    if (!script) {\n+      return null;\n+    }\n+    let newstate = true;\n+    if (script.isEnabled) {\n+      yPref.set(\n+        PREF_SCRIPTSDISABLED,\n+        `${script.filename},${yPref.get(PREF_SCRIPTSDISABLED)}`\n+      );\n+      newstate = false;\n+    } else {\n+      yPref.set(\n+        PREF_SCRIPTSDISABLED,\n+        yPref\n+          .get(PREF_SCRIPTSDISABLED)\n+          .replace(new RegExp(`^${script.filename},?|,${script.filename}`), \"\")\n+      );\n+    }\n+    Services.appinfo.invalidateCachesOnRestart();\n+    return { script: name, enabled: newstate };\n+  },\n \n-    toggleScript: function (el) {\n-      let isElement = !!el.tagName;\n-      if (!isElement && typeof el != \"string\") {\n-        return;\n-      }\n-      let script = _uc.scripts[isElement ? el.getAttribute(\"filename\") : el];\n-      if (!script) {\n-        console.log(\"no script to toggle\");\n-        return;\n-      }\n-      if (script.isEnabled) {\n-        yPref.set(\n-          _uc.PREF_SCRIPTSDISABLED,\n-          `${script.filename},${yPref.get(_uc.PREF_SCRIPTSDISABLED)}`\n-        );\n+  updateStyleSheet: function (name = \"../userChrome.css\", type) {\n+    return updateStyleSheet(name, type);\n+  },\n+\n+  updateMenuStatus: function (menu) {\n+    if (!menu) {\n+      return;\n+    }\n+    let disabledScripts = yPref.get(PREF_SCRIPTSDISABLED).split(\",\");\n+    for (let item of menu.children) {\n+      if (disabledScripts.includes(item.getAttribute(\"filename\"))) {\n+        item.removeAttribute(\"checked\");\n       } else {\n-        yPref.set(\n-          _uc.PREF_SCRIPTSDISABLED,\n-          yPref\n-            .get(_uc.PREF_SCRIPTSDISABLED)\n-            .replace(\n-              new RegExp(`^${script.filename},?|,${script.filename}`),\n-              \"\"\n-            )\n-        );\n+        item.setAttribute(\"checked\", \"true\");\n       }\n-      Services.appinfo.invalidateCachesOnRestart();\n-    },\n+    }\n+  },\n \n-    updateStyleSheet: function (name = \"../userChrome.css\", type) {\n-      return _uc.updateStyleSheet(name, type);\n-    },\n-\n-    updateMenuStatus: function (menu) {\n-      if (!menu) {\n-        return;\n+  startupFinished: function () {\n+    return new Promise((resolve) => {\n+      if (_ucjs.SESSION_RESTORED) {\n+        resolve();\n+      } else {\n+        let observer = (subject, topic, data) => {\n+          Services.obs.removeObserver(\n+            observer,\n+            \"sessionstore-windows-restored\"\n+          );\n+          resolve();\n+        };\n+        Services.obs.addObserver(observer, \"sessionstore-windows-restored\");\n       }\n-      let disabledScripts = yPref.get(_uc.PREF_SCRIPTSDISABLED).split(\",\");\n-      for (let item of menu.children) {\n-        if (disabledScripts.includes(item.getAttribute(\"filename\"))) {\n-          item.removeAttribute(\"checked\");\n-        } else {\n-          item.setAttribute(\"checked\", \"true\");\n-        }\n-      }\n-    },\n+    });\n+  },\n \n-    startupFinished: function () {\n+  windowIsReady: function (win) {\n+    if (win && win.isChromeWindow) {\n       return new Promise((resolve) => {\n-        if (_uc.SESSION_RESTORED) {\n+        if (win.gBrowserInit.delayedStartupFinished) {\n           resolve();\n         } else {\n           let observer = (subject, topic, data) => {\n-            Services.obs.removeObserver(\n-              observer,\n-              \"sessionstore-windows-restored\"\n-            );\n-            resolve();\n+            if (subject === win) {\n+              Services.obs.removeObserver(\n+                observer,\n+                \"browser-delayed-startup-finished\"\n+              );\n+              resolve();\n+            }\n           };\n-          Services.obs.addObserver(observer, \"sessionstore-windows-restored\");\n+          Services.obs.addObserver(\n+            observer,\n+            \"browser-delayed-startup-finished\"\n+          );\n         }\n       });\n-    },\n+    } else {\n+      return Promise.reject(new Error(\"reference is not a window\"));\n+    }\n+  },\n \n-    windowIsReady: function (win) {\n-      if (win && win.isChromeWindow) {\n-        return new Promise((resolve) => {\n-          if (win.gBrowserInit.delayedStartupFinished) {\n-            resolve();\n-          } else {\n-            let observer = (subject, topic, data) => {\n-              if (subject === win) {\n-                Services.obs.removeObserver(\n-                  observer,\n-                  \"browser-delayed-startup-finished\"\n-                );\n-                resolve();\n-              }\n-            };\n-            Services.obs.addObserver(\n-              observer,\n-              \"browser-delayed-startup-finished\"\n-            );\n-          }\n-        });\n-      } else {\n-        return Promise.reject(new Error(\"reference is not a window\"));\n-      }\n-    },\n+  registerHotkey: function (desc, func) {\n+    const validMods = [\"accel\", \"alt\", \"ctrl\", \"meta\", \"shift\"];\n+    const validKey = (k) =>\n+      /^[\\w-]$/.test(k) ? 1 : /^F(?:1[0,2]|[1-9])$/.test(k) ? 2 : 0;\n+    const NOK = (a) => typeof a != \"string\";\n+    const eToO = (e) => ({\n+      metaKey: e.metaKey,\n+      ctrlKey: e.ctrlKey,\n+      altKey: e.altKey,\n+      shiftKey: e.shiftKey,\n+      key: e.srcElement.getAttribute(\"key\"),\n+      id: e.srcElement.getAttribute(\"id\"),\n+    });\n \n-    registerHotkey: function (desc, func) {\n-      const validMods = [\"accel\", \"alt\", \"ctrl\", \"meta\", \"shift\"];\n-      const validKey = (k) =>\n-        /^[\\w-]$/.test(k) ? 1 : /^F(?:1[0,2]|[1-9])$/.test(k) ? 2 : 0;\n-      const NOK = (a) => typeof a != \"string\";\n-      const eToO = (e) => ({\n-        metaKey: e.metaKey,\n-        ctrlKey: e.ctrlKey,\n-        altKey: e.altKey,\n-        shiftKey: e.shiftKey,\n-        key: e.srcElement.getAttribute(\"key\"),\n-        id: e.srcElement.getAttribute(\"id\"),\n-      });\n+    if (NOK(desc.id) || NOK(desc.key) || NOK(desc.modifiers)) {\n+      return false;\n+    }\n \n-      if (NOK(desc.id) || NOK(desc.key) || NOK(desc.modifiers)) {\n+    try {\n+      let mods = desc.modifiers\n+        .toLowerCase()\n+        .split(\" \")\n+        .filter((a) => validMods.includes(a));\n+      let key = validKey(desc.key);\n+      if (!key || (mods.length === 0 && key === 1)) {\n         return false;\n       }\n \n-      try {\n-        let mods = desc.modifiers\n-          .toLowerCase()\n-          .split(\" \")\n-          .filter((a) => validMods.includes(a));\n-        let key = validKey(desc.key);\n-        if (!key || (mods.length === 0 && key === 1)) {\n-          return false;\n+      utils.windows.forEach((doc, win) => {\n+        if (doc.getElementById(desc.id)) {\n+          return;\n         }\n+        let details = {\n+          id: desc.id,\n+          modifiers: mods.join(\",\").replace(\"ctrl\", \"accel\"),\n+          oncommand: \"//\",\n+        };\n+        if (key === 1) {\n+          details.key = desc.key.toUpperCase();\n+        } else {\n+          details.keycode = `VK_${desc.key}`;\n+        }\n \n-        _uc.utils.windows.forEach((doc, win) => {\n-          if (doc.getElementById(desc.id)) {\n-            return;\n-          }\n-          let details = {\n-            id: desc.id,\n-            modifiers: mods.join(\",\").replace(\"ctrl\", \"accel\"),\n-            oncommand: \"//\",\n-          };\n-          if (key === 1) {\n-            details.key = desc.key.toUpperCase();\n-          } else {\n-            details.keycode = `VK_${desc.key}`;\n-          }\n+        let el = utils.createElement(doc, \"key\", details);\n \n-          let el = _uc.utils.createElement(doc, \"key\", details);\n-\n-          el.addEventListener(\"command\", (ev) => {\n-            func(ev.target.ownerGlobal, eToO(ev));\n-          });\n-          let keyset =\n-            doc.getElementById(\"mainKeyset\") ||\n-            doc.body.appendChild(\n-              _uc.utils.createElement(doc, \"keyset\", { id: \"ucKeys\" })\n-            );\n-          keyset.insertBefore(el, keyset.firstChild);\n+        el.addEventListener(\"command\", (ev) => {\n+          func(ev.target.ownerGlobal, eToO(ev));\n         });\n-      } catch (e) {\n-        console.error(e);\n-        return false;\n-      }\n-      return true;\n-    },\n-    loadURI: function (win, desc) {\n-      if (\n-        !win ||\n-        !desc ||\n-        !desc.url ||\n-        typeof desc.url !== \"string\" ||\n-        ![\"tab\", \"tabshifted\", \"window\", \"current\"].includes(desc.where)\n-      ) {\n-        return false;\n-      }\n-      const isJsURI = desc.url.slice(0, 11) === \"javascript:\";\n-      try {\n-        win.openTrustedLinkIn(desc.url, desc.where, {\n-          allowPopups: isJsURI,\n-          inBackground: false,\n-          allowInheritPrincipal: false,\n-          private: !!desc.private,\n-          userContextId: desc.url.startsWith(\"http\")\n-            ? desc.userContextId\n-            : null,\n-        });\n-      } catch (e) {\n-        console.error(e);\n-        return false;\n-      }\n-      return true;\n-    },\n-    get prefs() {\n-      return yPref;\n-    },\n+        let keyset =\n+          doc.getElementById(\"mainKeyset\") ||\n+          doc.body.appendChild(\n+            utils.createElement(doc, \"keyset\", { id: \"ucKeys\" })\n+          );\n+        keyset.insertBefore(el, keyset.firstChild);\n+      });\n+    } catch (e) {\n+      console.error(e);\n+      return false;\n+    }\n+    return true;\n+  },\n+  loadURI: function (win, desc) {\n+    if (\n+      !win ||\n+      !desc ||\n+      !desc.url ||\n+      typeof desc.url !== \"string\" ||\n+      ![\"tab\", \"tabshifted\", \"window\", \"current\"].includes(desc.where)\n+    ) {\n+      return false;\n+    }\n+    const isJsURI = desc.url.slice(0, 11) === \"javascript:\";\n+    try {\n+      win.openTrustedLinkIn(desc.url, desc.where, {\n+        allowPopups: isJsURI,\n+        inBackground: false,\n+        allowInheritPrincipal: false,\n+        private: !!desc.private,\n+        userContextId: desc.url.startsWith(\"http\") ? desc.userContextId : null,\n+      });\n+    } catch (e) {\n+      console.error(e);\n+      return false;\n+    }\n+    return true;\n+  },\n+  get prefs() {\n+    return yPref;\n+  },\n \n-    showNotification: async function (description) {\n-      await _uc.utils.startupFinished();\n-      let window = description.window;\n-      if (!(window && window.isChromeWindow)) {\n-        window = Services.wm.getMostRecentBrowserWindow();\n-      }\n-      let aNotificationBox = window.gNotificationBox;\n-      if (description.tab) {\n-        let aBrowser = description.tab.linkedBrowser;\n-        if (!aBrowser) {\n-          return;\n-        }\n-        aNotificationBox = window.gBrowser.getNotificationBox(aBrowser);\n-      }\n-      if (!aNotificationBox) {\n+  showNotification: async function (description) {\n+    await utils.startupFinished();\n+    let window = description.window;\n+    if (!(window && window.isChromeWindow)) {\n+      window = Services.wm.getMostRecentBrowserWindow();\n+    }\n+    let aNotificationBox = window.gNotificationBox;\n+    if (description.tab) {\n+      let aBrowser = description.tab.linkedBrowser;\n+      if (!aBrowser) {\n         return;\n       }\n-      let type = description.type || \"default\";\n-      let priority = aNotificationBox.PRIORITY_INFO_HIGH;\n-      switch (description.priority) {\n-        case \"system\":\n-          priority = aNotificationBox.PRIORITY_SYSTEM;\n-          break;\n-        case \"critical\":\n-          priority = aNotificationBox.PRIORITY_CRITICAL_HIGH;\n-          break;\n-        case \"warning\":\n-          priority = aNotificationBox.PRIORITY_WARNING_HIGH;\n-          break;\n-      }\n-      aNotificationBox.appendNotification(\n-        type,\n-        {\n-          label: description.label || \"ucUtils message\",\n-          image: \"chrome://browser/skin/notification-icons/popup.svg\",\n-          priority: priority,\n-          eventCallback:\n-            typeof description.callback === \"function\"\n-              ? description.callback\n-              : null,\n-        },\n-        description.buttons\n-      );\n-    },\n+      aNotificationBox = window.gBrowser.getNotificationBox(aBrowser);\n+    }\n+    if (!aNotificationBox) {\n+      return;\n+    }\n+    let type = description.type || \"default\";\n+    let priority = aNotificationBox.PRIORITY_INFO_HIGH;\n+    switch (description.priority) {\n+      case \"system\":\n+        priority = aNotificationBox.PRIORITY_SYSTEM;\n+        break;\n+      case \"critical\":\n+        priority = aNotificationBox.PRIORITY_CRITICAL_HIGH;\n+        break;\n+      case \"warning\":\n+        priority = aNotificationBox.PRIORITY_WARNING_HIGH;\n+        break;\n+    }\n+    aNotificationBox.appendNotification(\n+      type,\n+      {\n+        label: description.label || \"ucUtils message\",\n+        image: \"chrome://browser/skin/notification-icons/popup.svg\",\n+        priority: priority,\n+        eventCallback:\n+          typeof description.callback === \"function\"\n+            ? description.callback\n+            : null,\n+      },\n+      description.buttons\n+    );\n+  },\n \n-    restart: function (clearCache) {\n-      clearCache && Services.appinfo.invalidateCachesOnRestart();\n-      let cancelQuit = Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(\n-        Ci.nsISupportsPRBool\n-      );\n-      Services.obs.notifyObservers(\n-        cancelQuit,\n-        \"quit-application-requested\",\n-        \"restart\"\n-      );\n-      Services.startup.quit(\n-        Services.startup.eAttemptQuit | Services.startup.eRestart\n-      );\n-    },\n+  restart: function (clearCache) {\n+    clearCache && Services.appinfo.invalidateCachesOnRestart();\n+    let cancelQuit = Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(\n+      Ci.nsISupportsPRBool\n+    );\n+    Services.obs.notifyObservers(\n+      cancelQuit,\n+      \"quit-application-requested\",\n+      \"restart\"\n+    );\n+    Services.startup.quit(\n+      Services.startup.eAttemptQuit | Services.startup.eRestart\n+    );\n   },\n };\n \n-Object.freeze(_uc.utils);\n-_uc.utils.startupFinished().then(() => {\n-  _uc.SESSION_RESTORED = true;\n-});\n+Object.freeze(utils);\n \n-if (yPref.get(_uc.PREF_ENABLED) === undefined) {\n-  yPref.set(_uc.PREF_ENABLED, true);\n+if (yPref.get(PREF_ENABLED) === undefined) {\n+  yPref.set(PREF_ENABLED, true);\n }\n \n-if (yPref.get(_uc.PREF_SCRIPTSDISABLED) === undefined) {\n-  yPref.set(_uc.PREF_SCRIPTSDISABLED, \"\");\n+if (yPref.get(PREF_SCRIPTSDISABLED) === undefined) {\n+  yPref.set(PREF_SCRIPTSDISABLED, \"\");\n }\n \n+if (yPref.get(PREF_GBROWSERHACKENABLED) === undefined) {\n+  yPref.set(PREF_GBROWSERHACKENABLED, false);\n+}\n+\n+function showgBrowserNotification() {\n+  yPref.set(PREF_GBROWSERHACKENABLED, true);\n+  utils.showNotification({\n+    label: \"fx-autoconfig: Something was broken in last startup\",\n+    type: \"fx-autoconfig-gbrowser-notification\",\n+    priority: \"critical\",\n+    buttons: [\n+      {\n+        label: \"Why am I seeing this?\",\n+        callback: (notification) => {\n+          notification.ownerGlobal.openWebLinkIn(\n+            \"https://github.com/MrOtherGuy/fx-autoconfig#startup-error\",\n+            \"tab\"\n+          );\n+          return false;\n+        },\n+      },\n+    ],\n+  });\n+}\n+\n+function showBrokenNotification(window) {\n+  let aNotificationBox = window.gNotificationBox;\n+  aNotificationBox.appendNotification(\n+    \"fx-autoconfig-broken-notification\",\n+    {\n+      label: \"fx-autoconfig: Startup is broken\",\n+      image: \"chrome://browser/skin/notification-icons/popup.svg\",\n+      priority: \"critical\",\n+    },\n+    [\n+      {\n+        label: \"Enable workaround\",\n+        callback: (notification) => {\n+          yPref.set(\"userChromeJS.gBrowser_hack.required\", true);\n+          utils.restart(false);\n+          return false;\n+        },\n+      },\n+    ]\n+  );\n+}\n+\n+function escapeXUL(markup) {\n+  return markup.replace(/[<>&'\"]/g, (char) => {\n+    switch (char) {\n+      case `<`:\n+        return \"&lt;\";\n+      case `>`:\n+        return \"&gt;\";\n+      case `&`:\n+        return \"&amp;\";\n+      case `'`:\n+        return \"&apos;\";\n+      case '\"':\n+        return \"&quot;\";\n+    }\n+  });\n+}\n+\n function UserChrome_js() {\n-  _uc.getScripts();\n+  this.scripts = [];\n+  this.SESSION_RESTORED = false;\n+  this.isInitialWindow = true;\n+\n+  const gBrowserHackRequired = yPref.get(\"userChromeJS.gBrowser_hack.required\")\n+    ? 2\n+    : 0;\n+  const gBrowserHackEnabled = yPref.get(PREF_GBROWSERHACKENABLED) ? 1 : 0;\n+  this.GBROWSERHACK_ENABLED = gBrowserHackRequired | gBrowserHackEnabled;\n+\n+  if (!yPref.get(PREF_ENABLED) || !/^[\\w_]*$/.test(SCRIPT_DIR)) {\n+    console.log(\n+      \"Scripts are disabled or the given script directory name is invalid\"\n+    );\n+    return;\n+  }\n+  let files = getDirEntry(\"\", true);\n+  while (files.hasMoreElements()) {\n+    let file = files.getNext().QueryInterface(Ci.nsIFile);\n+    if (/\\.uc\\.js$/i.test(file.leafName)) {\n+      let script = ScriptData.fromFile(file);\n+      this.scripts.push(script);\n+      if (script.inbackground && script.isEnabled) {\n+        try {\n+          ChromeUtils.import(`chrome://userscripts/content/${script.filename}`);\n+          script.isRunning = true;\n+        } catch (e) {\n+          console.error(e);\n+        }\n+      }\n+    }\n+  }\n+  this.scripts.sort((a, b) => a.loadOrder > b.loadOrder);\n+\n   Services.obs.addObserver(this, \"domwindowopened\", false);\n }\n \n UserChrome_js.prototype = {\n@@ -731,67 +790,88 @@\n     let regex =\n       /^chrome:(?!\\/\\/global\\/content\\/(commonDialog|alerts\\/alert)\\.xhtml)|about:(?!blank)/i;\n     // Don't inject scripts to modal prompt windows or notifications\n     if (regex.test(window.location.href)) {\n-      Object.defineProperty(window, \"_ucUtils\", { get: () => _uc.utils });\n+      Object.defineProperty(window, \"_ucUtils\", { get: () => utils });\n       document.allowUnsafeHTML = false; // https://bugzilla.mozilla.org/show_bug.cgi?id=1432966\n-      if (window._gBrowser) {\n-        // bug 1443849\n+\n+      // This is a hack to make gBrowser available for scripts.\n+      // Without it, scripts would need to check if gBrowser exists and deal\n+      // with it somehow. See bug 1443849\n+      const _gb = \"_gBrowser\" in window;\n+      if (this.GBROWSERHACK_ENABLED && _gb) {\n         window.gBrowser = window._gBrowser;\n+      } else if (_gb && this.isInitialWindow) {\n+        this.isInitialWindow = false;\n+        let timeout = window.setTimeout(() => {\n+          showBrokenNotification(window);\n+        }, 5000);\n+        utils.windowIsReady(window).then(() => {\n+          // startup is fine, clear timeout\n+          window.clearTimeout(timeout);\n+        });\n       }\n       let isWindow = window.isChromeWindow;\n \n-      /* Add a way to toggle scripts in tools menu */\n-      let menu, popup, item;\n-      let ce = _uc.utils.createElement;\n-      if (isWindow) {\n-        menu = document.querySelector(\"#menu_openDownloads\");\n-        if (menu) {\n-          try {\n-            popup = ce(document, \"menupopup\", {\n-              id: \"menuUserScriptsPopup\",\n-              onpopupshown: `_ucUtils.updateMenuStatus(this)`,\n-            });\n-            item = ce(document, \"menu\", {\n-              id: \"userScriptsMenu\",\n-              label: \"userScripts\",\n-            });\n-          } catch (e) {\n-            isWindow = false;\n+      // Inject scripts to window\n+      if (yPref.get(PREF_ENABLED)) {\n+        const disabledScripts = (yPref.get(PREF_SCRIPTSDISABLED) || \"\").split(\n+          \",\"\n+        );\n+        for (let script of this.scripts) {\n+          if (script.inbackground) {\n+            continue;\n           }\n-        } else {\n-          isWindow = false;\n+          if (!disabledScripts.includes(script.filename)) {\n+            script.tryLoadIntoWindow(window);\n+          }\n         }\n       }\n-      if (yPref.get(_uc.PREF_ENABLED)) {\n-        Object.values(_uc.scripts).forEach((script) => {\n-          _uc.loadScript(script, window);\n-          if (isWindow) {\n-            popup.appendChild(\n-              ce(document, \"menuitem\", {\n-                type: \"checkbox\",\n-                label: script.name || script.filename,\n-                filename: script.filename,\n-                checked: \"true\",\n-                oncommand: `_ucUtils.toggleScript(this)`,\n-              })\n-            );\n-          }\n-        });\n-      }\n-      if (isWindow) {\n-        popup.appendChild(ce(document, \"menuseparator\", {}));\n-        popup.appendChild(\n-          ce(document, \"menuitem\", {\n-            label: \"Restart now!\",\n-            oncommand: \"_ucUtils.restart(true)\",\n-            tooltiptext: \"Toggling scripts requires a restart\",\n-          })\n+\n+      // Add simple script menu to menubar tools popup\n+      const menu = document.querySelector(\"#menu_openDownloads\");\n+      if (isWindow && menu) {\n+        window.MozXULElement.insertFTLIfNeeded(\n+          \"browser/preferences/preferences.ftl\"\n         );\n-        item.appendChild(popup);\n-        menu.parentNode.insertBefore(item, menu);\n+        let menuFragment = window.MozXULElement.parseXULToFragment(`\n+          <menu id=\"userScriptsMenu\" label=\"userScripts\">\n+            <menupopup id=\"menuUserScriptsPopup\" onpopupshown=\"_ucUtils.updateMenuStatus(this)\">\n+              <menuseparator></menuseparator>\n+              <menuitem id=\"userScriptsRestart\" label=\"Restart\" oncommand=\"_ucUtils.restart(true)\" tooltiptext=\"Toggling scripts requires restart\"></menuitem>\n+            </menupopup>\n+          </menu>\n+        `);\n+        const itemsFragment = window.MozXULElement.parseXULToFragment(\"\");\n+        for (let script of this.scripts) {\n+          itemsFragment.append(\n+            window.MozXULElement.parseXULToFragment(`\n+              <menuitem type=\"checkbox\"\n+                        label=\"${escapeXUL(script.name || script.filename)}\"\n+                        filename=\"${escapeXUL(script.filename)}\"\n+                        checked=\"true\"\n+                        oncommand=\"_ucUtils.toggleScript(this)\">\n+              </menuitem>\n+          `)\n+          );\n+        }\n+        menuFragment\n+          .getElementById(\"menuUserScriptsPopup\")\n+          .prepend(itemsFragment);\n+        menu.parentNode.insertBefore(menuFragment, menu);\n+        document.l10n\n+          .formatValue(\"should-restart-title\")\n+          .then((c) =>\n+            document\n+              .getElementById(\"userScriptsRestart\")\n+              .setAttribute(\"label\", c)\n+          );\n       }\n     }\n   },\n };\n-\n-!Services.appinfo.inSafeMode && new UserChrome_js();\n+const _ucjs = !Services.appinfo.inSafeMode && new UserChrome_js();\n+_ucjs &&\n+  utils.startupFinished().then(() => {\n+    _ucjs.SESSION_RESTORED = true;\n+    _ucjs.GBROWSERHACK_ENABLED === 2 && showgBrowserNotification();\n+  });\n"
                }
            ],
            "date": 1649508267113,
            "name": "Commit-0",
            "content": "let EXPORTED_SYMBOLS = [];\n\nconsole.warn(\"Browser is executing custom scripts via autoconfig\");\nconst { Services } = ChromeUtils.import(\"resource://gre/modules/Services.jsm\");\n\nconst yPref = {\n  get: function (prefPath) {\n    const sPrefs = Services.prefs;\n    try {\n      switch (sPrefs.getPrefType(prefPath)) {\n        case 0:\n          return undefined;\n        case 32:\n          return sPrefs.getStringPref(prefPath);\n        case 64:\n          return sPrefs.getIntPref(prefPath);\n        case 128:\n          return sPrefs.getBoolPref(prefPath);\n      }\n    } catch (ex) {\n      return undefined;\n    }\n    return;\n  },\n  set: function (prefPath, value) {\n    const sPrefs = Services.prefs;\n    switch (typeof value) {\n      case \"string\":\n        return sPrefs.setCharPref(prefPath, value) || value;\n      case \"number\":\n        return sPrefs.setIntPref(prefPath, value) || value;\n      case \"boolean\":\n        return sPrefs.setBoolPref(prefPath, value) || value;\n    }\n    return;\n  },\n  addListener: (a, b) => {\n    let o = (q, w, e) => b(yPref.get(e), e);\n    Services.prefs.addObserver(a, o);\n    return { pref: a, observer: o };\n  },\n  removeListener: (a) => Services.prefs.removeObserver(a.pref, a.observer),\n};\n\nconst SHARED_GLOBAL = {};\nObject.defineProperty(SHARED_GLOBAL, \"widgetCallbacks\", { value: new Map() });\n\nfunction resolveChromeURL(str) {\n  const registry = Cc[\"@mozilla.org/chrome/chrome-registry;1\"].getService(\n    Ci.nsIChromeRegistry\n  );\n  try {\n    return registry.convertChromeURL(\n      Services.io.newURI(str.replace(/\\\\/g, \"/\"))\n    ).spec;\n  } catch (e) {\n    console.error(e);\n    return \"\";\n  }\n}\n// relative to \"chrome\" folder\nfunction resolveChromePath(str) {\n  let parts = resolveChromeURL(str).split(\"/\");\n  return parts.slice(parts.indexOf(\"chrome\") + 1, parts.length - 1).join(\"/\");\n}\n\nlet _uc = {\n  BROWSERCHROME: \"chrome://browser/content/browser.xhtml\",\n  PREF_ENABLED: \"userChromeJS.enabled\",\n  PREF_SCRIPTSDISABLED: \"userChromeJS.scriptsDisabled\",\n\n  SCRIPT_DIR: resolveChromePath(\"chrome://userscripts/content/\"),\n  RESOURCE_DIR: resolveChromePath(\"chrome://userchrome/content/\"),\n  BASE_FILEURI: Services.io\n    .getProtocolHandler(\"file\")\n    .QueryInterface(Ci.nsIFileProtocolHandler)\n    .getURLSpecFromDir(Services.dirsvc.get(\"UChrm\", Ci.nsIFile)),\n\n  SESSION_RESTORED: false,\n\n  get chromeDir() {\n    return Services.dirsvc.get(\"UChrm\", Ci.nsIFile);\n  },\n\n  getDirEntry: function (filename, isLoader = false) {\n    filename = filename.replace(\"\\\\\", \"/\");\n    let pathParts = (\n      (filename.startsWith(\"..\")\n        ? \"\"\n        : isLoader\n        ? _uc.SCRIPT_DIR\n        : _uc.RESOURCE_DIR) +\n      \"/\" +\n      filename\n    )\n      .split(\"/\")\n      .filter((a) => !!a && a != \"..\");\n    let entry = _uc.chromeDir;\n\n    for (let part of pathParts) {\n      entry.append(part);\n    }\n    if (!entry.exists()) {\n      return null;\n    }\n    if (entry.isDirectory()) {\n      return entry.directoryEntries.QueryInterface(Ci.nsISimpleEnumerator);\n    } else if (entry.isFile()) {\n      return entry;\n    } else {\n      return null;\n    }\n  },\n\n  updateStyleSheet: function (name, type) {\n    if (type) {\n      let sss = Cc[\"@mozilla.org/content/style-sheet-service;1\"].getService(\n        Ci.nsIStyleSheetService\n      );\n      try {\n        let uri = Services.io.newURI(`chrome://userchrome/content/${name}`);\n        switch (type) {\n          case \"agent\":\n            sss.unregisterSheet(uri, sss.AGENT_SHEET);\n            sss.loadAndRegisterSheet(uri, sss.AGENT_SHEET);\n            return true;\n          case \"author\":\n            sss.unregisterSheet(uri, sss.AUTHOR_SHEET);\n            sss.loadAndRegisterSheet(uri, sss.AUTHOR_SHEET);\n            return true;\n          default:\n            return false;\n        }\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n    }\n    let entry = _uc.utils.getFSEntry(name);\n    if (!(entry && entry.isFile())) {\n      return false;\n    }\n    let recentWindow = Services.wm.getMostRecentBrowserWindow();\n    if (!recentWindow) {\n      return false;\n    }\n    function recurseImports(sheet, all) {\n      let z = 0;\n      let rule = sheet.cssRules[0];\n      // loop through import rules and check that the \"all\"\n      // doesn't already contain the same object\n      while (rule instanceof CSSImportRule && !all.includes(rule.styleSheet)) {\n        all.push(rule.styleSheet);\n        recurseImports(rule.styleSheet, all);\n        rule = sheet.cssRules[++z];\n      }\n      return all;\n    }\n\n    let sheets = recentWindow.InspectorUtils.getAllStyleSheets(\n      recentWindow.document,\n      false\n    );\n\n    sheets = sheets.flatMap((x) => recurseImports(x, [x]));\n\n    // If a sheet is imported multiple times, then there will be\n    // duplicates, because style system does create an object for\n    // each instace but that's OK since sheets.find below will\n    // only find the first instance and reload that which is\n    // \"probably\" fine.\n    let entryFilePath = `file:///${entry.path.replaceAll(\"\\\\\", \"/\")}`;\n\n    let target = sheets.find((sheet) => sheet.href === entryFilePath);\n    if (target) {\n      recentWindow.InspectorUtils.parseStyleSheet(\n        target,\n        _uc.utils.readFile(entry)\n      );\n      return true;\n    }\n    return false;\n  },\n\n  getScripts: function () {\n    this.scripts = {};\n    if (!yPref.get(_uc.PREF_ENABLED) || !/^[\\w_]*$/.test(_uc.SCRIPT_DIR)) {\n      console.log(\n        \"Scripts are disabled or the given script directory name is invalid\"\n      );\n      return;\n    }\n    let files = _uc.getDirEntry(\"\", true);\n    while (files.hasMoreElements()) {\n      let file = files.getNext().QueryInterface(Ci.nsIFile);\n      if (/\\.uc\\.js$/i.test(file.leafName)) {\n        let script = _uc.getScriptData(file);\n        if (script.inbackground && script.isEnabled) {\n          try {\n            Cu.import(`chrome://userscripts/content/${script.filename}`);\n          } catch (e) {\n            console.error(e);\n          }\n        }\n      }\n    }\n  },\n\n  getScriptData: function (aFile) {\n    let header = (_uc.utils\n      .readFile(aFile, true)\n      .match(\n        /^\\/\\/ ==UserScript==\\s*\\n(?:.*\\n)*?\\/\\/ ==\\/UserScript==\\s*\\n/m\n      ) || [\"\"])[0];\n    let match,\n      rex = {\n        include: [],\n        exclude: [],\n      };\n    let findNextRe = /^\\/\\/ @(include|exclude)\\s+(.+)\\s*$/gm;\n    while ((match = findNextRe.exec(header))) {\n      rex[match[1]].push(\n        match[2].replace(/^main$/i, _uc.BROWSERCHROME).replace(/\\*/g, \".*?\")\n      );\n    }\n    if (!rex.include.length) {\n      rex.include.push(_uc.BROWSERCHROME);\n    }\n    let exclude = rex.exclude.length ? `(?!${rex.exclude.join(\"$|\")}$)` : \"\";\n    let def = [\"\", \"\"];\n    let author = (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1];\n    let filename = aFile.leafName || \"\";\n\n    return (this.scripts[filename] = {\n      filename: filename,\n      name: (header.match(/\\/\\/ @name\\s+(.+)\\s*$/im) || def)[1],\n      charset: (header.match(/\\/\\/ @charset\\s+(.+)\\s*$/im) || def)[1],\n      description: (header.match(/\\/\\/ @description\\s+(.+)\\s*$/im) || def)[1],\n      version: (header.match(/\\/\\/ @version\\s+(.+)\\s*$/im) || def)[1],\n      author: (header.match(/\\/\\/ @author\\s+(.+)\\s*$/im) || def)[1],\n      regex: new RegExp(`^${exclude}(${rex.include.join(\"|\") || \".*\"})$`, \"i\"),\n      id: (header.match(/\\/\\/ @id\\s+(.+)\\s*$/im) || [\n        \"\",\n        filename.split(\".uc.js\")[0] + \"@\" + (author || \"userChromeJS\"),\n      ])[1],\n      homepageURL: (header.match(/\\/\\/ @homepageURL\\s+(.+)\\s*$/im) || def)[1],\n      downloadURL: (header.match(/\\/\\/ @downloadURL\\s+(.+)\\s*$/im) || def)[1],\n      updateURL: (header.match(/\\/\\/ @updateURL\\s+(.+)\\s*$/im) || def)[1],\n      optionsURL: (header.match(/\\/\\/ @optionsURL\\s+(.+)\\s*$/im) || def)[1],\n      startup: (header.match(/\\/\\/ @startup\\s+(.+)\\s*$/im) || def)[1],\n      onlyonce: /\\/\\/ @onlyonce\\b/.test(header),\n      inbackground: /\\/\\/ @backgroundmodule\\b/.test(header),\n      ignoreCache: /\\/\\/ @ignorecache\\b/.test(header),\n      isRunning: false,\n      get isEnabled() {\n        return (\n          (yPref.get(_uc.PREF_SCRIPTSDISABLED) || \"\")\n            .split(\",\")\n            .indexOf(this.filename) === -1\n        );\n      },\n    });\n  },\n\n  maybeRunStartUp: (script, win) => {\n    if (\n      script.startup &&\n      /^\\w*$/.test(script.startup) &&\n      SHARED_GLOBAL[script.startup] &&\n      typeof SHARED_GLOBAL[script.startup]._startup === \"function\"\n    ) {\n      SHARED_GLOBAL[script.startup]._startup(win);\n    }\n  },\n\n  loadScript: function (script, win) {\n    if (\n      script.inbackground ||\n      !script.regex.test(win.location.href) ||\n      !script.isEnabled\n    ) {\n      return;\n    }\n    try {\n      if (script.onlyonce && script.isRunning) {\n        _uc.maybeRunStartUp(script, win);\n        return;\n      }\n\n      Services.scriptloader.loadSubScriptWithOptions(\n        `chrome://userscripts/content/${script.filename}`,\n        {\n          target: win,\n          ignoreCache: script.ignoreCache,\n        }\n      );\n\n      script.isRunning = true;\n      _uc.maybeRunStartUp(script, win);\n    } catch (ex) {\n      console.error(ex);\n    }\n    return;\n  },\n\n  // things to be exported for use by userscripts\n  utils: {\n    get sharedGlobal() {\n      return SHARED_GLOBAL;\n    },\n\n    createElement: function (doc, tag, props, isHTML = false) {\n      let el = isHTML ? doc.createElement(tag) : doc.createXULElement(tag);\n      for (let prop in props) {\n        el.setAttribute(prop, props[prop]);\n      }\n      return el;\n    },\n\n    createWidget(desc) {\n      if (!desc || !desc.id) {\n        console.error(\"custom widget description is missing 'id' property\");\n        return null;\n      }\n      if (![\"toolbaritem\", \"toolbarbutton\"].includes(desc.type)) {\n        console.error(\"custom widget has unsupported type: \" + desc.type);\n        return null;\n      }\n      const CUI = Services.wm.getMostRecentBrowserWindow().CustomizableUI;\n      let newWidget = CUI.getWidget(desc.id);\n\n      if (newWidget && newWidget.hasOwnProperty(\"source\")) {\n        // very likely means that the widget with this id already exists\n        // There isn't a very reliable way to 'really' check if it exists or not\n        return newWidget;\n      }\n      // This is pretty ugly but makes onBuild much cleaner.\n      let itemStyle = \"\";\n      if (desc.image) {\n        if (desc.type === \"toolbarbutton\") {\n          itemStyle += \"list-style-image:\";\n        } else {\n          itemStyle += \"background: transparent center no-repeat \";\n        }\n        itemStyle += `url(chrome://userChrome/content/${desc.image});`;\n        itemStyle += desc.style || \"\";\n      }\n      SHARED_GLOBAL.widgetCallbacks.set(desc.id, desc.callback);\n\n      return CUI.createWidget({\n        id: desc.id,\n        type: \"custom\",\n        onBuild: function (aDocument) {\n          let toolbaritem = aDocument.createXULElement(desc.type);\n          let props = {\n            id: desc.id,\n            class: `toolbarbutton-1 chromeclass-toolbar-additional ${\n              desc.class ? desc.class : \"\"\n            }`,\n            overflows: !!desc.overflows,\n            label: desc.label || desc.id,\n            tooltiptext: desc.tooltip || desc.id,\n            style: itemStyle,\n            onclick: `${\n              desc.allEvents ? \"\" : \"event.button===0 && \"\n            }_ucUtils.sharedGlobal.widgetCallbacks.get(this.id)(event,window)`,\n          };\n          for (let p in props) {\n            toolbaritem.setAttribute(p, props[p]);\n          }\n          return toolbaritem;\n        },\n      });\n    },\n\n    readFile: function (aFile, metaOnly = false) {\n      let stream = Cc[\n        \"@mozilla.org/network/file-input-stream;1\"\n      ].createInstance(Ci.nsIFileInputStream);\n      let cvstream = Cc[\n        \"@mozilla.org/intl/converter-input-stream;1\"\n      ].createInstance(Ci.nsIConverterInputStream);\n      try {\n        stream.init(aFile, 0x01, 0, 0);\n        cvstream.init(\n          stream,\n          \"UTF-8\",\n          1024,\n          Ci.nsIConverterInputStream.DEFAULT_REPLACEMENT_CHARACTER\n        );\n      } catch (e) {\n        console.error(e);\n        return null;\n      }\n      let content = \"\",\n        data = {};\n      while (cvstream.readString(4096, data)) {\n        content += data.value;\n        if (metaOnly && content.indexOf(\"// ==/UserScript==\") > 0) {\n          break;\n        }\n      }\n      cvstream.close();\n      stream.close();\n      return content.replace(/\\r\\n?/g, \"\\n\");\n    },\n\n    createFileURI: (fileName = \"\") => {\n      fileName = String(fileName);\n      let u = resolveChromeURL(`chrome://userchrome/content/${fileName}`);\n      return fileName ? u : u.substr(0, u.lastIndexOf(\"/\") + 1);\n    },\n\n    get chromeDir() {\n      return {\n        get files() {\n          return _uc.chromeDir.directoryEntries.QueryInterface(\n            Ci.nsISimpleEnumerator\n          );\n        },\n        uri: _uc.BASE_FILEURI,\n      };\n    },\n\n    getFSEntry: (fileName) => _uc.getDirEntry(fileName),\n\n    getScriptData: () => {\n      let scripts = [];\n      for (let script in _uc.scripts) {\n        let data = {};\n        let o = _uc.scripts[script];\n        for (let p in o) {\n          if (p != \"isEnabled\") {\n            data[p] = o[p];\n          }\n        }\n        scripts.push(data);\n      }\n      return scripts;\n    },\n\n    get windows() {\n      return {\n        get: function (onlyBrowsers = true) {\n          let windows = Services.wm.getEnumerator(\n            onlyBrowsers ? \"navigator:browser\" : null\n          );\n          let wins = [];\n          while (windows.hasMoreElements()) {\n            wins.push(windows.getNext());\n          }\n          return wins;\n        },\n        forEach: function (fun, onlyBrowsers = true) {\n          let wins = this.get(onlyBrowsers);\n          wins.forEach((w) => fun(w.document, w));\n        },\n      };\n    },\n\n    toggleScript: function (el) {\n      let isElement = !!el.tagName;\n      if (!isElement && typeof el != \"string\") {\n        return;\n      }\n      let script = _uc.scripts[isElement ? el.getAttribute(\"filename\") : el];\n      if (!script) {\n        console.log(\"no script to toggle\");\n        return;\n      }\n      if (script.isEnabled) {\n        yPref.set(\n          _uc.PREF_SCRIPTSDISABLED,\n          `${script.filename},${yPref.get(_uc.PREF_SCRIPTSDISABLED)}`\n        );\n      } else {\n        yPref.set(\n          _uc.PREF_SCRIPTSDISABLED,\n          yPref\n            .get(_uc.PREF_SCRIPTSDISABLED)\n            .replace(\n              new RegExp(`^${script.filename},?|,${script.filename}`),\n              \"\"\n            )\n        );\n      }\n      Services.appinfo.invalidateCachesOnRestart();\n    },\n\n    updateStyleSheet: function (name = \"../userChrome.css\", type) {\n      return _uc.updateStyleSheet(name, type);\n    },\n\n    updateMenuStatus: function (menu) {\n      if (!menu) {\n        return;\n      }\n      let disabledScripts = yPref.get(_uc.PREF_SCRIPTSDISABLED).split(\",\");\n      for (let item of menu.children) {\n        if (disabledScripts.includes(item.getAttribute(\"filename\"))) {\n          item.removeAttribute(\"checked\");\n        } else {\n          item.setAttribute(\"checked\", \"true\");\n        }\n      }\n    },\n\n    startupFinished: function () {\n      return new Promise((resolve) => {\n        if (_uc.SESSION_RESTORED) {\n          resolve();\n        } else {\n          let observer = (subject, topic, data) => {\n            Services.obs.removeObserver(\n              observer,\n              \"sessionstore-windows-restored\"\n            );\n            resolve();\n          };\n          Services.obs.addObserver(observer, \"sessionstore-windows-restored\");\n        }\n      });\n    },\n\n    windowIsReady: function (win) {\n      if (win && win.isChromeWindow) {\n        return new Promise((resolve) => {\n          if (win.gBrowserInit.delayedStartupFinished) {\n            resolve();\n          } else {\n            let observer = (subject, topic, data) => {\n              if (subject === win) {\n                Services.obs.removeObserver(\n                  observer,\n                  \"browser-delayed-startup-finished\"\n                );\n                resolve();\n              }\n            };\n            Services.obs.addObserver(\n              observer,\n              \"browser-delayed-startup-finished\"\n            );\n          }\n        });\n      } else {\n        return Promise.reject(new Error(\"reference is not a window\"));\n      }\n    },\n\n    registerHotkey: function (desc, func) {\n      const validMods = [\"accel\", \"alt\", \"ctrl\", \"meta\", \"shift\"];\n      const validKey = (k) =>\n        /^[\\w-]$/.test(k) ? 1 : /^F(?:1[0,2]|[1-9])$/.test(k) ? 2 : 0;\n      const NOK = (a) => typeof a != \"string\";\n      const eToO = (e) => ({\n        metaKey: e.metaKey,\n        ctrlKey: e.ctrlKey,\n        altKey: e.altKey,\n        shiftKey: e.shiftKey,\n        key: e.srcElement.getAttribute(\"key\"),\n        id: e.srcElement.getAttribute(\"id\"),\n      });\n\n      if (NOK(desc.id) || NOK(desc.key) || NOK(desc.modifiers)) {\n        return false;\n      }\n\n      try {\n        let mods = desc.modifiers\n          .toLowerCase()\n          .split(\" \")\n          .filter((a) => validMods.includes(a));\n        let key = validKey(desc.key);\n        if (!key || (mods.length === 0 && key === 1)) {\n          return false;\n        }\n\n        _uc.utils.windows.forEach((doc, win) => {\n          if (doc.getElementById(desc.id)) {\n            return;\n          }\n          let details = {\n            id: desc.id,\n            modifiers: mods.join(\",\").replace(\"ctrl\", \"accel\"),\n            oncommand: \"//\",\n          };\n          if (key === 1) {\n            details.key = desc.key.toUpperCase();\n          } else {\n            details.keycode = `VK_${desc.key}`;\n          }\n\n          let el = _uc.utils.createElement(doc, \"key\", details);\n\n          el.addEventListener(\"command\", (ev) => {\n            func(ev.target.ownerGlobal, eToO(ev));\n          });\n          let keyset =\n            doc.getElementById(\"mainKeyset\") ||\n            doc.body.appendChild(\n              _uc.utils.createElement(doc, \"keyset\", { id: \"ucKeys\" })\n            );\n          keyset.insertBefore(el, keyset.firstChild);\n        });\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n      return true;\n    },\n    loadURI: function (win, desc) {\n      if (\n        !win ||\n        !desc ||\n        !desc.url ||\n        typeof desc.url !== \"string\" ||\n        ![\"tab\", \"tabshifted\", \"window\", \"current\"].includes(desc.where)\n      ) {\n        return false;\n      }\n      const isJsURI = desc.url.slice(0, 11) === \"javascript:\";\n      try {\n        win.openTrustedLinkIn(desc.url, desc.where, {\n          allowPopups: isJsURI,\n          inBackground: false,\n          allowInheritPrincipal: false,\n          private: !!desc.private,\n          userContextId: desc.url.startsWith(\"http\")\n            ? desc.userContextId\n            : null,\n        });\n      } catch (e) {\n        console.error(e);\n        return false;\n      }\n      return true;\n    },\n    get prefs() {\n      return yPref;\n    },\n\n    showNotification: async function (description) {\n      await _uc.utils.startupFinished();\n      let window = description.window;\n      if (!(window && window.isChromeWindow)) {\n        window = Services.wm.getMostRecentBrowserWindow();\n      }\n      let aNotificationBox = window.gNotificationBox;\n      if (description.tab) {\n        let aBrowser = description.tab.linkedBrowser;\n        if (!aBrowser) {\n          return;\n        }\n        aNotificationBox = window.gBrowser.getNotificationBox(aBrowser);\n      }\n      if (!aNotificationBox) {\n        return;\n      }\n      let type = description.type || \"default\";\n      let priority = aNotificationBox.PRIORITY_INFO_HIGH;\n      switch (description.priority) {\n        case \"system\":\n          priority = aNotificationBox.PRIORITY_SYSTEM;\n          break;\n        case \"critical\":\n          priority = aNotificationBox.PRIORITY_CRITICAL_HIGH;\n          break;\n        case \"warning\":\n          priority = aNotificationBox.PRIORITY_WARNING_HIGH;\n          break;\n      }\n      aNotificationBox.appendNotification(\n        type,\n        {\n          label: description.label || \"ucUtils message\",\n          image: \"chrome://browser/skin/notification-icons/popup.svg\",\n          priority: priority,\n          eventCallback:\n            typeof description.callback === \"function\"\n              ? description.callback\n              : null,\n        },\n        description.buttons\n      );\n    },\n\n    restart: function (clearCache) {\n      clearCache && Services.appinfo.invalidateCachesOnRestart();\n      let cancelQuit = Cc[\"@mozilla.org/supports-PRBool;1\"].createInstance(\n        Ci.nsISupportsPRBool\n      );\n      Services.obs.notifyObservers(\n        cancelQuit,\n        \"quit-application-requested\",\n        \"restart\"\n      );\n      Services.startup.quit(\n        Services.startup.eAttemptQuit | Services.startup.eRestart\n      );\n    },\n  },\n};\n\nObject.freeze(_uc.utils);\n_uc.utils.startupFinished().then(() => {\n  _uc.SESSION_RESTORED = true;\n});\n\nif (yPref.get(_uc.PREF_ENABLED) === undefined) {\n  yPref.set(_uc.PREF_ENABLED, true);\n}\n\nif (yPref.get(_uc.PREF_SCRIPTSDISABLED) === undefined) {\n  yPref.set(_uc.PREF_SCRIPTSDISABLED, \"\");\n}\n\nfunction UserChrome_js() {\n  _uc.getScripts();\n  Services.obs.addObserver(this, \"domwindowopened\", false);\n}\n\nUserChrome_js.prototype = {\n  observe: function (aSubject, aTopic, aData) {\n    aSubject.addEventListener(\"DOMContentLoaded\", this, true);\n  },\n\n  handleEvent: function (aEvent) {\n    let document = aEvent.originalTarget;\n    let window = document.defaultView;\n    let regex =\n      /^chrome:(?!\\/\\/global\\/content\\/(commonDialog|alerts\\/alert)\\.xhtml)|about:(?!blank)/i;\n    // Don't inject scripts to modal prompt windows or notifications\n    if (regex.test(window.location.href)) {\n      Object.defineProperty(window, \"_ucUtils\", { get: () => _uc.utils });\n      document.allowUnsafeHTML = false; // https://bugzilla.mozilla.org/show_bug.cgi?id=1432966\n      if (window._gBrowser) {\n        // bug 1443849\n        window.gBrowser = window._gBrowser;\n      }\n      let isWindow = window.isChromeWindow;\n\n      /* Add a way to toggle scripts in tools menu */\n      let menu, popup, item;\n      let ce = _uc.utils.createElement;\n      if (isWindow) {\n        menu = document.querySelector(\"#menu_openDownloads\");\n        if (menu) {\n          try {\n            popup = ce(document, \"menupopup\", {\n              id: \"menuUserScriptsPopup\",\n              onpopupshown: `_ucUtils.updateMenuStatus(this)`,\n            });\n            item = ce(document, \"menu\", {\n              id: \"userScriptsMenu\",\n              label: \"userScripts\",\n            });\n          } catch (e) {\n            isWindow = false;\n          }\n        } else {\n          isWindow = false;\n        }\n      }\n      if (yPref.get(_uc.PREF_ENABLED)) {\n        Object.values(_uc.scripts).forEach((script) => {\n          _uc.loadScript(script, window);\n          if (isWindow) {\n            popup.appendChild(\n              ce(document, \"menuitem\", {\n                type: \"checkbox\",\n                label: script.name || script.filename,\n                filename: script.filename,\n                checked: \"true\",\n                oncommand: `_ucUtils.toggleScript(this)`,\n              })\n            );\n          }\n        });\n      }\n      if (isWindow) {\n        popup.appendChild(ce(document, \"menuseparator\", {}));\n        popup.appendChild(\n          ce(document, \"menuitem\", {\n            label: \"Restart now!\",\n            oncommand: \"_ucUtils.restart(true)\",\n            tooltiptext: \"Toggling scripts requires a restart\",\n          })\n        );\n        item.appendChild(popup);\n        menu.parentNode.insertBefore(item, menu);\n      }\n    }\n  },\n};\n\n!Services.appinfo.inSafeMode && new UserChrome_js();\n"
        }
    ]
}